<html xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.w3.org/1999/xhtml"><head><style type="text/css">
                    body {
                        font-family: Trebuchet MS,Verdana,Arial;
                        font-size: 0.8em;
                    }
                    table {
                    	font-size: 1em;
                    	border-spacing: 0;
                    }
                    table td {
                    	padding: 0;
                    	border-left: solid 1px #888;
                    	border-right: solid 1px #888;
                    	border-bottom: solid 1px #888;
                    }
                    table th {
                    	padding: 2px;
                    }
                    table tr {
                    	 height: 20px;
                    }
                    th.file {
                    	width: 400px;
                    }
                    th.mutants, th.sequence_points {
                    	width: 118px;
                    }
                    h1 {
                        font-size: 1.5em;
                    }
                    pre {
                        font-family: Consolas, Lucida Console, Courier New, Courier;
                    }
                    .red {
                        background-color: #fcc;
                    }
                    .amber {
                        background-color: #fff8e8;
                    }
                    .green {
                        background-color: #cfc;
                    }
                    .title, th {
                        background-color: #000;
                        color: #fff;
                        font-weight: bold;
                        text-align: left;
                    }
                    .bar-wrap {
                    	position: relative;
                    }
                    .bar-wrap, .bar-value, .bar-text {
                    	width: 120px;
                    	height: 20px;
                    }
                    .bar-wrap, .bar-value {
                    	background-color: #fdd;
                    }
                    .bar-text {
                    	position: absolute;
                    	top: 0; left: 0;
                    	padding-top: 2px;
                    	color: #000;
                    	text-align: center;
                    	width: 100%;
                    }
                </style></head><body><table><thead><tr><th class="file">File</th><th class="mutants">Mutants</th><th class="sequence_points">Sequence points</th></tr></thead><tbody><tr><td>InstructionExtensions.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 93.33333333333333%"><div class="bar-text">14 /
    			15</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 57.142857142857146%"><div class="bar-text">4 /
    			7</div></div></div></td></tr><tr><td>TypeResolver.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">68 /
    			68</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 69.6969696969697%"><div class="bar-text">23 /
    			33</div></div></div></td></tr><tr><td>VariableWriteTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">257 /
    			257</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">45 /
    			45</div></div></div></td></tr><tr><td>VariableReadTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">291 /
    			291</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">50 /
    			50</div></div></div></td></tr><tr><td>SequencePointDeletionTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">266 /
    			266</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 80.76923076923077%"><div class="bar-text">42 /
    			52</div></div></div></td></tr><tr><td>OpCodeRotationTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">95 /
    			95</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">18 /
    			18</div></div></div></td></tr><tr><td>MethodTurtleBase.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">118 /
    			118</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 87.09677419354838%"><div class="bar-text">27 /
    			31</div></div></div></td></tr><tr><td>TestDirectory.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">194 /
    			194</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 60%"><div class="bar-text">33 /
    			55</div></div></div></td></tr><tr><td>MutationTest.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">162 /
    			162</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 68.35443037974683%"><div class="bar-text">54 /
    			79</div></div></div></td></tr><tr><td>MutationTestBuilder.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">4 /
    			4</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 60%"><div class="bar-text">3 /
    			5</div></div></div></td></tr><tr><td>Module.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">59 /
    			59</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 57.69230769230769%"><div class="bar-text">15 /
    			26</div></div></div></td></tr><tr><td>MethodTestedAttribute.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">7 /
    			7</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 45.45454545454545%"><div class="bar-text">5 /
    			11</div></div></div></td></tr><tr><td>MethodDefinitionResolver.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">42 /
    			42</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 63.333333333333336%"><div class="bar-text">19 /
    			30</div></div></div></td></tr><tr><td>ConsoleProcessFactory.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">94 /
    			94</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 65.625%"><div class="bar-text">21 /
    			32</div></div></div></td></tr></tbody></table><h1>InstructionExtensions.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Linq;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">using Mono.Cecil;</span>
  26:        : <span class="white">using Mono.Cecil.Cil;</span>
  27:        : <span class="white"></span>
  28:        : <span class="white">namespace NinjaTurtles</span>
  29:        : <span class="white">{</span>
  30:        : <span class="white">    internal static class InstructionExtensions</span>
  31:        : <span class="white">    {</span>
  32:        : <span class="white">        internal static  bool IsMeaninglessUnconditionalBranch(this Instruction instruction)</span>
  33:        : <span class="amber">        {</span>
  34:   13/14: <span class="red">            return instruction.OpCode == OpCodes.Br</span>
  35:     5/5: <span class="green">                &amp;&amp; ((Instruction)instruction.Operand).Offset == instruction.Next.Offset;</span>
  36:        : <span class="amber">        }</span>
  37:        : <span class="white"></span>
  38:        : <span class="white">        internal static bool FollowsSequence(this Instruction instruction, params OpCode[] sequence)</span>
  39:        : <span class="white">        {</span>
  40:        : <span class="white">            if (instruction.OpCode != sequence[0]) return false;</span>
  41:        : <span class="white">            if (sequence.Length == 1) return true;</span>
  42:        : <span class="white">            var newSequence = new OpCode[sequence.Length - 1];</span>
  43:        : <span class="white">            Array.Copy(sequence, 1, newSequence, 0, newSequence.Length);</span>
  44:        : <span class="white">            return instruction.Next.FollowsSequence(newSequence);</span>
  45:        : <span class="white">        }</span>
  46:        : <span class="white"></span>
  47:        : <span class="white">        internal static bool IsPartOfSequence(this Instruction instruction, params OpCode[] sequence)</span>
  48:        : <span class="white">        {</span>
  49:        : <span class="white">            if (!sequence.Distinct().Contains(instruction.OpCode)) return false;</span>
  50:        : <span class="white">            var startInstruction = instruction;</span>
  51:        : <span class="white">            for (int i = 0; i &lt; sequence.Length; i++)</span>
  52:        : <span class="white">            {</span>
  53:        : <span class="white">                if (startInstruction == null) break;</span>
  54:        : <span class="white">                if (startInstruction.FollowsSequence(sequence)) return true;</span>
  55:        : <span class="white">                startInstruction = startInstruction.Previous;</span>
  56:        : <span class="white">            }</span>
  57:        : <span class="white">            return false;</span>
  58:        : <span class="white">        }</span>
  59:        : <span class="white"></span>
  60:        : <span class="white">        internal static bool IsPartOfCompilerGeneratedDispose(this Instruction instruction)</span>
  61:        : <span class="white">        {</span>
  62:        : <span class="white">            if (instruction.IsPartOfSequence(OpCodes.Leave,</span>
  63:        : <span class="white">                OpCodes.Ldloc, OpCodes.Ldnull, OpCodes.Ceq,</span>
  64:        : <span class="white">                OpCodes.Stloc, OpCodes.Ldloc, OpCodes.Brtrue,</span>
  65:        : <span class="white">                OpCodes.Ldloc, OpCodes.Callvirt))</span>
  66:        : <span class="white">            {</span>
  67:        : <span class="white">                while (instruction.OpCode != OpCodes.Callvirt)</span>
  68:        : <span class="white">                {</span>
  69:        : <span class="white">                    instruction = instruction.Next;</span>
  70:        : <span class="white">                }</span>
  71:        : <span class="white">                var method = ((MethodReference)instruction.Operand);</span>
  72:        : <span class="white">                return method.Name == "Dispose";</span>
  73:        : <span class="white">            }</span>
  74:        : <span class="white">            if (instruction.IsPartOfSequence(OpCodes.Leave,</span>
  75:        : <span class="white">                OpCodes.Ldloc, OpCodes.Ldnull, OpCodes.Ceq,</span>
  76:        : <span class="white">                OpCodes.Brtrue,</span>
  77:        : <span class="white">                OpCodes.Ldloc, OpCodes.Callvirt))</span>
  78:        : <span class="white">            {</span>
  79:        : <span class="white">                while (instruction.OpCode != OpCodes.Callvirt)</span>
  80:        : <span class="white">                {</span>
  81:        : <span class="white">                    instruction = instruction.Next;</span>
  82:        : <span class="white">                }</span>
  83:        : <span class="white">                var method = ((MethodReference)instruction.Operand);</span>
  84:        : <span class="white">                return method.Name == "Dispose";</span>
  85:        : <span class="white">            }</span>
  86:        : <span class="white">            return false;</span>
  87:        : <span class="white">        }</span>
  88:        : <span class="white"></span>
  89:        : <span class="white">    }</span>
  90:        : <span class="white">}</span>
</pre><h1>TypeResolver.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Linq;</span>
  25:        : <span class="white">using System.Reflection;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">using NLog;</span>
  28:        : <span class="white"></span>
  29:        : <span class="white">namespace NinjaTurtles</span>
  30:        : <span class="white">{</span>
  31:        : <span class="white">    internal class TypeResolver</span>
  32:        : <span class="white">    {</span>
  33:        : <span class="white">        #region Logging</span>
  34:        : <span class="white"></span>
  35:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();</span>
  36:        : <span class="white"></span>
  37:        : <span class="white">        #endregion</span>
  38:        : <span class="white"></span>
  39:        : <span class="white">        internal static Type ResolveTypeFromReferences(Assembly callingAssembly, string className)</span>
  40:        : <span class="amber">        {</span>
  41:     1/1: <span class="green">            _log.Debug("Resolving type \"{0}\" in \"{1}\".", className, callingAssembly.GetName().Name);</span>
  42:     2/2: <span class="green">            Type type = ResolveTypeFromReferences(callingAssembly, className, new List&lt;string&gt;());</span>
  43:     6/6: <span class="green">            if (type == null)</span>
  44:        : <span class="amber">            {</span>
  45:     1/1: <span class="green">                _log.Error("Could not find type \"{0}\".", className);</span>
  46:        : <span class="amber">            }</span>
  47:     2/2: <span class="green">            return type;</span>
  48:        : <span class="amber">        }</span>
  49:        : <span class="white"></span>
  50:        : <span class="white">        private static Type ResolveTypeFromReferences(Assembly assembly, string className, IList&lt;string&gt; consideredAssemblies)</span>
  51:        : <span class="amber">        {</span>
  52:     2/2: <span class="green">            _log.Trace("Searching for type \"{0}\" in \"{1}\".", className, assembly.GetName().Name);</span>
  53:     3/3: <span class="green">            var type = assembly.GetTypes().SingleOrDefault(t =&gt; t.FullName == className);</span>
  54:     6/6: <span class="green">            if (type != null)</span>
  55:        : <span class="amber">            {</span>
  56:     2/2: <span class="green">                _log.Trace("Found type \"{0}\" in \"{1}\".", className, assembly.GetName().Name);</span>
  57:     4/4: <span class="green">                return type;</span>
  58:        : <span class="white">            }</span>
  59:   10/10: <span class="green">            foreach (var reference in assembly.GetReferencedAssemblies())</span>
  60:        : <span class="amber">            {</span>
  61:     7/7: <span class="green">                if (consideredAssemblies.Contains(reference.Name)) continue;</span>
  62:     1/1: <span class="green">                consideredAssemblies.Add(reference.Name);</span>
  63:     1/1: <span class="green">                Assembly referencedAssembly = Assembly.Load(reference);</span>
  64:     3/3: <span class="green">                type = ResolveTypeFromReferences(referencedAssembly, className, consideredAssemblies);</span>
  65:     6/6: <span class="green">                if (type != null)</span>
  66:        : <span class="amber">                {</span>
  67:     3/3: <span class="green">                    return type;</span>
  68:        : <span class="white">                }</span>
  69:     5/5: <span class="green">            }</span>
  70:     2/2: <span class="green">            return null;</span>
  71:        : <span class="amber">        }</span>
  72:        : <span class="white">    }</span>
  73:        : <span class="white">}</span>
  74:        : <span class="white"></span>
</pre><h1>VariableWriteTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Linq;</span>
  25:        : <span class="white"></span>
  26:        : <span class="white">using Mono.Cecil;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;</span>
  28:        : <span class="white"></span>
  29:        : <span class="white">namespace NinjaTurtles.Turtles</span>
  30:        : <span class="white">{</span>
  31:        : <span class="white">    /// &lt;summary&gt;</span>
  32:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that identifies local</span>
  33:        : <span class="white">    /// variables of the same type, and permutes any assignments to them. For</span>
  34:        : <span class="white">    /// example, if two &lt;see cref="Int32" /&gt; variables &lt;c&gt;a&lt;/c&gt; and &lt;c&gt;b&lt;/c&gt;</span>
  35:        : <span class="white">    /// exist, then an assignment to &lt;c&gt;a&lt;/c&gt; will be replaced by one to</span>
  36:        : <span class="white">    /// &lt;c&gt;b&lt;/c&gt;, and vice versa.</span>
  37:        : <span class="white">    /// &lt;/summary&gt;</span>
  38:        : <span class="white">    public class VariableWriteTurtle : MethodTurtleBase</span>
  39:        : <span class="white">    {</span>
  40:        : <span class="white">        /// &lt;summary&gt;</span>
  41:        : <span class="white">        /// Performs the actual code mutations, returning each with</span>
  42:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.</span>
  43:        : <span class="white">        /// &lt;/summary&gt;</span>
  44:        : <span class="white">        /// &lt;remarks&gt;</span>
  45:        : <span class="white">        /// Implementing classes should yield the result obtained by calling</span>
  46:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.</span>
  47:        : <span class="white">        /// &lt;/remarks&gt;</span>
  48:        : <span class="white">        /// &lt;param name="method"&gt;</span>
  49:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
  50:        : <span class="white">        /// testing is to be carried out.</span>
  51:        : <span class="white">        /// &lt;/param&gt;</span>
  52:        : <span class="white">        /// &lt;param name="module"&gt;</span>
  53:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
  54:        : <span class="white">        /// containing assembly.</span>
  55:        : <span class="white">        /// &lt;/param&gt;</span>
  56:        : <span class="white">        /// &lt;returns&gt;</span>
  57:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
  58:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
  59:        : <span class="white">        /// &lt;/returns&gt;</span>
  60:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)</span>
  61:        : <span class="white">        {</span>
  62:     1/1: <span class="green">            var variablesByType = GroupVariablesByType(method);</span>
  63:     1/1: <span class="green">            PopulateOperandsInVariables(method, variablesByType);</span>
  64:        : <span class="white"></span>
  65:     7/7: <span class="green">            if (!variablesByType.Any(kv =&gt; variablesByType[kv.Key].Count &gt; 1))</span>
  66:        : <span class="white">            {</span>
  67:     2/2: <span class="green">                yield break;</span>
  68:        : <span class="white">            }</span>
  69:        : <span class="white"></span>
  70:   18/18: <span class="green">            foreach (var keyValuePair in variablesByType.Where(kv =&gt; kv.Value.Count &gt; 1))</span>
  71:        : <span class="white">            {</span>
  72:     1/1: <span class="green">                var variables = keyValuePair.Value.ToList();</span>
  73:   31/31: <span class="green">                for (int index = 0; index &lt; method.Body.Instructions.Count; index++)</span>
  74:        : <span class="white">                {</span>
  75:     5/5: <span class="green">                    var instruction = method.Body.Instructions[index];</span>
  76:   13/13: <span class="green">                    if (instruction.OpCode == OpCodes.Ldloc &amp;&amp; instruction.Next.OpCode == OpCodes.Ret) continue;</span>
  77:        : <span class="white"></span>
  78:     5/5: <span class="green">                    int oldIndex = -1;</span>
  79:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Stloc)</span>
  80:        : <span class="white">                    {</span>
  81:     1/1: <span class="green">                        int variableIndex = ((VariableDefinition)instruction.Operand).Index;</span>
  82:     5/5: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == variableIndex);</span>
  83:        : <span class="white">                    }</span>
  84:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Stfld)</span>
  85:        : <span class="white">                    {</span>
  86:     1/1: <span class="green">                        string fieldName = ((FieldDefinition)instruction.Operand).Name;</span>
  87:     5/5: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == fieldName);</span>
  88:        : <span class="white">                    }</span>
  89:        : <span class="white"></span>
  90:   13/13: <span class="green">                    if (oldIndex &lt; 0) continue;</span>
  91:        : <span class="white"></span>
  92:     1/1: <span class="green">                    OpCode originalOpCode = instruction.OpCode;</span>
  93:     1/1: <span class="green">                    object originalOperand = instruction.Operand;</span>
  94:     6/6: <span class="green">                    var originalVariable = variables[oldIndex];</span>
  95:        : <span class="white"></span>
  96:   31/31: <span class="green">                    for (int newIndex = 0; newIndex &lt; variables.Count; newIndex++)</span>
  97:        : <span class="white">                    {</span>
  98:   17/17: <span class="green">                        if (newIndex == oldIndex) continue;</span>
  99:     6/6: <span class="green">                        var variable = variables[newIndex];</span>
 100:   10/10: <span class="green">                        if (variable.Operand == null) continue;</span>
 101:        : <span class="white"></span>
 102:     7/7: <span class="green">                        if (instruction.IsPartOfCompilerGeneratedDispose())</span>
 103:        : <span class="white">                        {</span>
 104:     2/2: <span class="green">                            continue;</span>
 105:        : <span class="white">                        }</span>
 106:        : <span class="white"></span>
 107:     2/2: <span class="green">                        instruction.OpCode = variable.GetWriteOpCode();</span>
 108:     2/2: <span class="green">                        instruction.Operand = variable.Operand;</span>
 109:        : <span class="white"></span>
 110:     7/7: <span class="green">                        var description =</span>
 111:     7/7: <span class="green">                            string.Format(</span>
 112:     7/7: <span class="green">                                "{0:x4}: write substitution {1}.{2} =&gt; {1}.{3}",</span>
 113:     7/7: <span class="green">                                GetOriginalOffset(index),</span>
 114:     7/7: <span class="green">                                keyValuePair.Key.Name,</span>
 115:     7/7: <span class="green">                                originalVariable.Name,</span>
 116:     7/7: <span class="green">                                variable.Name);</span>
 117:        : <span class="white"></span>
 118:     5/5: <span class="green">                        MutantMetaData mutation = DoYield(method, module, description, index);</span>
 119:   12/12: <span class="green">                        yield return mutation;</span>
 120:        : <span class="white"></span>
 121:        : <span class="white">                    }</span>
 122:     1/1: <span class="green">                    instruction.OpCode = originalOpCode;</span>
 123:     1/1: <span class="green">                    instruction.Operand = originalOperand;</span>
 124:        : <span class="white">                }</span>
 125:        : <span class="white">            }</span>
 126:     2/2: <span class="green">        }</span>
 127:        : <span class="white"></span>
 128:        : <span class="white">        private static IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; GroupVariablesByType(MethodDefinition method)</span>
 129:        : <span class="white">        {</span>
 130:        : <span class="white">            IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables = new Dictionary&lt;TypeReference, IList&lt;Variable&gt;&gt;();</span>
 131:        : <span class="white">            foreach (var variable in method.Body.Variables)</span>
 132:        : <span class="white">            {</span>
 133:        : <span class="white">                var type = variable.VariableType;</span>
 134:        : <span class="white">                if (!variables.ContainsKey(type))</span>
 135:        : <span class="white">                {</span>
 136:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());</span>
 137:        : <span class="white">                }</span>
 138:        : <span class="white">                variables[type].Add(new Variable(VariableType.Local, variable.Index, variable.Name));</span>
 139:        : <span class="white">            }</span>
 140:        : <span class="white">            foreach (var field in method.DeclaringType.Fields)</span>
 141:        : <span class="white">            {</span>
 142:        : <span class="white">                var type = field.FieldType;</span>
 143:        : <span class="white">                if (!variables.ContainsKey(type))</span>
 144:        : <span class="white">                {</span>
 145:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());</span>
 146:        : <span class="white">                }</span>
 147:        : <span class="white">                variables[type].Add(new Variable(VariableType.Field, -1, field.Name));</span>
 148:        : <span class="white">            }</span>
 149:        : <span class="white">            return variables;</span>
 150:        : <span class="white">        }</span>
 151:        : <span class="white"></span>
 152:        : <span class="white">        private static void PopulateOperandsInVariables(MethodDefinition method, IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables)</span>
 153:        : <span class="white">        {</span>
 154:        : <span class="white">            foreach (var instruction in method.Body.Instructions)</span>
 155:        : <span class="white">            {</span>
 156:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldloc)</span>
 157:        : <span class="white">                {</span>
 158:        : <span class="white">                    var variableDefinition = (VariableDefinition)instruction.Operand;</span>
 159:        : <span class="white">                    int index = variableDefinition.Index;</span>
 160:        : <span class="white">                    if (!variables.ContainsKey(variableDefinition.VariableType)) continue;</span>
 161:        : <span class="white">                    var variable =</span>
 162:        : <span class="white">                        variables[variableDefinition.VariableType]</span>
 163:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == index);</span>
 164:        : <span class="white">                    if (variable != null)</span>
 165:        : <span class="white">                    {</span>
 166:        : <span class="white">                        variable.Operand = instruction.Operand;</span>
 167:        : <span class="white">                    }</span>
 168:        : <span class="white">                }</span>
 169:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldfld)</span>
 170:        : <span class="white">                {</span>
 171:        : <span class="white">                    var fieldDefinition = (FieldDefinition)instruction.Operand;</span>
 172:        : <span class="white">                    string name = fieldDefinition.Name;</span>
 173:        : <span class="white">                    if (!variables.ContainsKey(fieldDefinition.FieldType)) continue;</span>
 174:        : <span class="white">                    var variable =</span>
 175:        : <span class="white">                        variables[fieldDefinition.FieldType]</span>
 176:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == name);</span>
 177:        : <span class="white">                    if (variable != null)</span>
 178:        : <span class="white">                    {</span>
 179:        : <span class="white">                        variable.Operand = instruction.Operand;</span>
 180:        : <span class="white">                    }</span>
 181:        : <span class="white">                }</span>
 182:        : <span class="white">            }</span>
 183:        : <span class="white">        }</span>
 184:        : <span class="white">    }</span>
 185:        : <span class="white">}</span>
</pre><h1>VariableReadTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Linq;</span>
  25:        : <span class="white"></span>
  26:        : <span class="white">using Mono.Cecil;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;</span>
  28:        : <span class="white"></span>
  29:        : <span class="white">namespace NinjaTurtles.Turtles</span>
  30:        : <span class="white">{</span>
  31:        : <span class="white">    /// &lt;summary&gt;</span>
  32:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that identifies local</span>
  33:        : <span class="white">    /// variables, method parameters and fields of the same type, and permutes</span>
  34:        : <span class="white">    /// any reads from them. For example, if two &lt;see cref="Int32" /&gt;</span>
  35:        : <span class="white">    /// parameters &lt;c&gt;a&lt;/c&gt; and &lt;c&gt;b&lt;/c&gt; exist, along with a local variable</span>
  36:        : <span class="white">    /// &lt;c&gt;c&lt;/c&gt; of the same type, then a read from &lt;c&gt;a&lt;/c&gt; will be replaced</span>
  37:        : <span class="white">    /// by one from &lt;c&gt;b&lt;/c&gt; and &lt;c&gt;c&lt;/c&gt; in turn, and so on.</span>
  38:        : <span class="white">    /// &lt;/summary&gt;</span>
  39:        : <span class="white">    public class VariableReadTurtle : MethodTurtleBase</span>
  40:        : <span class="white">    {</span>
  41:        : <span class="white">        /// &lt;summary&gt;</span>
  42:        : <span class="white">        /// Performs the actual code mutations, returning each with</span>
  43:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.</span>
  44:        : <span class="white">        /// &lt;/summary&gt;</span>
  45:        : <span class="white">        /// &lt;remarks&gt;</span>
  46:        : <span class="white">        /// Implementing classes should yield the result obtained by calling</span>
  47:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.</span>
  48:        : <span class="white">        /// &lt;/remarks&gt;</span>
  49:        : <span class="white">        /// &lt;param name="method"&gt;</span>
  50:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
  51:        : <span class="white">        /// testing is to be carried out.</span>
  52:        : <span class="white">        /// &lt;/param&gt;</span>
  53:        : <span class="white">        /// &lt;param name="module"&gt;</span>
  54:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
  55:        : <span class="white">        /// containing assembly.</span>
  56:        : <span class="white">        /// &lt;/param&gt;</span>
  57:        : <span class="white">        /// &lt;returns&gt;</span>
  58:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
  59:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
  60:        : <span class="white">        /// &lt;/returns&gt;</span>
  61:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)</span>
  62:        : <span class="white">        {</span>
  63:     1/1: <span class="green">            var variablesByType = GroupVariablesByType(method);</span>
  64:     1/1: <span class="green">            PopulateOperandsInVariables(method, variablesByType);</span>
  65:        : <span class="white"></span>
  66:     7/7: <span class="green">            if (!variablesByType.Any(kv =&gt; variablesByType[kv.Key].Count &gt; 1))</span>
  67:        : <span class="white">            {</span>
  68:     2/2: <span class="green">                yield break;</span>
  69:        : <span class="white">            }</span>
  70:        : <span class="white"></span>
  71:   18/18: <span class="green">            foreach (var keyValuePair in variablesByType.Where(kv =&gt; kv.Value.Count &gt; 1))</span>
  72:        : <span class="white">            {</span>
  73:     1/1: <span class="green">                var variables = keyValuePair.Value.ToList();</span>
  74:   31/31: <span class="green">                for (int index = 0; index &lt; method.Body.Instructions.Count; index++)</span>
  75:        : <span class="white">                {</span>
  76:     5/5: <span class="green">                    var instruction = method.Body.Instructions[index];</span>
  77:   13/13: <span class="green">                    if (instruction.OpCode == OpCodes.Ldloc &amp;&amp; instruction.Next.OpCode == OpCodes.Ret) continue;</span>
  78:        : <span class="white"></span>
  79:     5/5: <span class="green">                    int oldIndex = -1;</span>
  80:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldarg)</span>
  81:        : <span class="white">                    {</span>
  82:     1/1: <span class="green">                        int parameterIndex = ((ParameterDefinition)instruction.Operand).Sequence;</span>
  83:     5/5: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Parameter &amp;&amp; v.Index == parameterIndex);</span>
  84:        : <span class="white">                    }</span>
  85:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldloc)</span>
  86:        : <span class="white">                    {</span>
  87:     1/1: <span class="green">                        int variableIndex = ((VariableDefinition)instruction.Operand).Index;</span>
  88:     5/5: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == variableIndex);</span>
  89:        : <span class="white">                    }</span>
  90:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldfld)</span>
  91:        : <span class="white">                    {</span>
  92:     1/1: <span class="green">                        string fieldName = ((FieldDefinition)instruction.Operand).Name;</span>
  93:     5/5: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == fieldName);</span>
  94:        : <span class="white">                    }</span>
  95:        : <span class="white"></span>
  96:   13/13: <span class="green">                    if (oldIndex &lt; 0) continue;</span>
  97:        : <span class="white"></span>
  98:     1/1: <span class="green">                    OpCode originalOpCode = instruction.OpCode;</span>
  99:     1/1: <span class="green">                    object originalOperand = instruction.Operand;</span>
 100:     6/6: <span class="green">                    var originalVariable = variables[oldIndex];</span>
 101:        : <span class="white"></span>
 102:   31/31: <span class="green">                    for (int newIndex = 0; newIndex &lt; variables.Count; newIndex++)</span>
 103:        : <span class="white">                    {</span>
 104:   17/17: <span class="green">                        if (newIndex == oldIndex) continue;</span>
 105:     6/6: <span class="green">                        var variable = variables[newIndex];</span>
 106:   10/10: <span class="green">                        if (variable.Operand == null) continue;</span>
 107:        : <span class="white"></span>
 108:   19/19: <span class="green">                        if (variable.Type == VariableType.Parameter</span>
 109:   19/19: <span class="green">                            &amp;&amp; instruction.OpCode == OpCodes.Ldloc</span>
 110:   19/19: <span class="green">                            &amp;&amp; instruction.Previous.OpCode == OpCodes.Stloc</span>
 111:   19/19: <span class="green">                            &amp;&amp; ((VariableDefinition)instruction.Operand).Index == ((VariableDefinition)instruction.Previous.Operand).Index</span>
 112:   19/19: <span class="green">                            &amp;&amp; instruction.Previous.Previous.OpCode == OpCodes.Ldarg</span>
 113:   19/19: <span class="green">                            &amp;&amp; ((ParameterDefinition)instruction.Previous.Previous.Operand).Index == variable.Index)</span>
 114:        : <span class="white">                        {</span>
 115:        : <span class="white">                            // The .NET compiler sometimes adds a pointless</span>
 116:        : <span class="white">                            // cache of a parameter into a local variable</span>
 117:        : <span class="white">                            // (oddly, Mono doesn't seem to). We need to not</span>
 118:        : <span class="white">                            // mutate in this scenario.</span>
 119:     2/2: <span class="green">                            continue;</span>
 120:        : <span class="white">                        }</span>
 121:        : <span class="white"></span>
 122:     7/7: <span class="green">                        if (instruction.IsPartOfCompilerGeneratedDispose())</span>
 123:        : <span class="white">                        {</span>
 124:     2/2: <span class="green">                            continue;</span>
 125:        : <span class="white">                        }</span>
 126:        : <span class="white"></span>
 127:     2/2: <span class="green">                        instruction.OpCode = variable.GetReadOpCode();</span>
 128:     2/2: <span class="green">                        instruction.Operand = variable.Operand;</span>
 129:        : <span class="white"></span>
 130:     7/7: <span class="green">                        var description =</span>
 131:     7/7: <span class="green">                            string.Format(</span>
 132:     7/7: <span class="green">                                "{0:x4}: read substitution {1}.{2} =&gt; {1}.{3}",</span>
 133:     7/7: <span class="green">                                GetOriginalOffset(index),</span>
 134:     7/7: <span class="green">                                keyValuePair.Key.Name,</span>
 135:     7/7: <span class="green">                                originalVariable.Name,</span>
 136:     7/7: <span class="green">                                variable.Name);</span>
 137:        : <span class="white"></span>
 138:     5/5: <span class="green">                        var mutantMetaData = DoYield(method, module, description, index);</span>
 139:   12/12: <span class="green">                        yield return mutantMetaData;</span>
 140:        : <span class="white">                    }</span>
 141:     1/1: <span class="green">                    instruction.OpCode = originalOpCode;</span>
 142:     1/1: <span class="green">                    instruction.Operand = originalOperand;</span>
 143:        : <span class="white">                }</span>
 144:        : <span class="white">            }</span>
 145:     2/2: <span class="green">        }</span>
 146:        : <span class="white"></span>
 147:        : <span class="white">        private static IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; GroupVariablesByType(MethodDefinition method)</span>
 148:        : <span class="white">        {</span>
 149:        : <span class="white">            IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables = new Dictionary&lt;TypeReference, IList&lt;Variable&gt;&gt;();</span>
 150:        : <span class="white">            int offset = method.IsStatic ? 0 : 1;</span>
 151:        : <span class="white">            foreach (var parameter in method.Parameters)</span>
 152:        : <span class="white">            {</span>
 153:        : <span class="white">                var type = parameter.ParameterType;</span>
 154:        : <span class="white">                if (!variables.ContainsKey(type))</span>
 155:        : <span class="white">                {</span>
 156:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());</span>
 157:        : <span class="white">                }</span>
 158:        : <span class="white">                variables[type].Add(new Variable(VariableType.Parameter, parameter.Index + offset, parameter.Name));</span>
 159:        : <span class="white">            }</span>
 160:        : <span class="white">            foreach (var variable in method.Body.Variables)</span>
 161:        : <span class="white">            {</span>
 162:        : <span class="white">                var type = variable.VariableType;</span>
 163:        : <span class="white">                if (!variables.ContainsKey(type))</span>
 164:        : <span class="white">                {</span>
 165:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());</span>
 166:        : <span class="white">                }</span>
 167:        : <span class="white">                variables[type].Add(new Variable(VariableType.Local, variable.Index, variable.Name));</span>
 168:        : <span class="white">            }</span>
 169:        : <span class="white">            foreach (var field in method.DeclaringType.Fields)</span>
 170:        : <span class="white">            {</span>
 171:        : <span class="white">                var type = field.FieldType;</span>
 172:        : <span class="white">                if (!variables.ContainsKey(type))</span>
 173:        : <span class="white">                {</span>
 174:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());</span>
 175:        : <span class="white">                }</span>
 176:        : <span class="white">                variables[type].Add(new Variable(VariableType.Field, -1, field.Name));</span>
 177:        : <span class="white">            }</span>
 178:        : <span class="white">            return variables;</span>
 179:        : <span class="white">        }</span>
 180:        : <span class="white"></span>
 181:        : <span class="white">        private static void PopulateOperandsInVariables(MethodDefinition method, IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables)</span>
 182:        : <span class="white">        {</span>
 183:        : <span class="white">            foreach (var instruction in method.Body.Instructions)</span>
 184:        : <span class="white">            {</span>
 185:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldarg)</span>
 186:        : <span class="white">                {</span>
 187:        : <span class="white">                    var parameterDefinition = (ParameterDefinition)instruction.Operand;</span>
 188:        : <span class="white">                    int sequence = parameterDefinition.Sequence;</span>
 189:        : <span class="white">                    if (!variables.ContainsKey(parameterDefinition.ParameterType)) continue;</span>
 190:        : <span class="white">                    var variable =</span>
 191:        : <span class="white">                        variables[parameterDefinition.ParameterType]</span>
 192:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Parameter &amp;&amp; v.Index == sequence);</span>
 193:        : <span class="white">                    if (variable != null)</span>
 194:        : <span class="white">                    {</span>
 195:        : <span class="white">                        variable.Operand = instruction.Operand;</span>
 196:        : <span class="white">                    }</span>
 197:        : <span class="white">                }</span>
 198:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldloc)</span>
 199:        : <span class="white">                {</span>
 200:        : <span class="white">                    var variableDefinition = (VariableDefinition)instruction.Operand;</span>
 201:        : <span class="white">                    int index = variableDefinition.Index;</span>
 202:        : <span class="white">                    if (!variables.ContainsKey(variableDefinition.VariableType)) continue;</span>
 203:        : <span class="white">                    var variable =</span>
 204:        : <span class="white">                        variables[variableDefinition.VariableType]</span>
 205:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == index);</span>
 206:        : <span class="white">                    if (variable != null)</span>
 207:        : <span class="white">                    {</span>
 208:        : <span class="white">                        variable.Operand = instruction.Operand;</span>
 209:        : <span class="white">                    }</span>
 210:        : <span class="white">                }</span>
 211:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldfld)</span>
 212:        : <span class="white">                {</span>
 213:        : <span class="white">                    var fieldDefinition = (FieldDefinition)instruction.Operand;</span>
 214:        : <span class="white">                    string name = fieldDefinition.Name;</span>
 215:        : <span class="white">                    if (!variables.ContainsKey(fieldDefinition.FieldType)) continue;</span>
 216:        : <span class="white">                    var variable =</span>
 217:        : <span class="white">                        variables[fieldDefinition.FieldType]</span>
 218:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == name);</span>
 219:        : <span class="white">                    if (variable != null)</span>
 220:        : <span class="white">                    {</span>
 221:        : <span class="white">                        variable.Operand = instruction.Operand;</span>
 222:        : <span class="white">                    }</span>
 223:        : <span class="white">                }</span>
 224:        : <span class="white">            }</span>
 225:        : <span class="white">        }</span>
 226:        : <span class="white">    }</span>
 227:        : <span class="white">}</span>
</pre><h1>SequencePointDeletionTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System.Collections.Generic;</span>
  23:        : <span class="white">using System.Linq;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">using Mono.Cecil;</span>
  26:        : <span class="white">using Mono.Cecil.Cil;</span>
  27:        : <span class="white"></span>
  28:        : <span class="white">namespace NinjaTurtles.Turtles</span>
  29:        : <span class="white">{</span>
  30:        : <span class="white">    /// &lt;summary&gt;</span>
  31:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that removes from the</span>
  32:        : <span class="white">    /// compiled IL each sequence point in turn (with the exception of</span>
  33:        : <span class="white">    /// structurally vital ones and compiler generated ones).</span>
  34:        : <span class="white">    /// &lt;/summary&gt;</span>
  35:        : <span class="white">    public class SequencePointDeletionTurtle : MethodTurtleBase</span>
  36:        : <span class="white">    {</span>
  37:        : <span class="white">        /// &lt;summary&gt;</span>
  38:        : <span class="white">        /// Performs the actual code mutations, returning each with</span>
  39:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.</span>
  40:        : <span class="white">        /// &lt;/summary&gt;</span>
  41:        : <span class="white">        /// &lt;remarks&gt;</span>
  42:        : <span class="white">        /// Implementing classes should yield the result obtained by calling</span>
  43:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.</span>
  44:        : <span class="white">        /// &lt;/remarks&gt;</span>
  45:        : <span class="white">        /// &lt;param name="method"&gt;</span>
  46:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
  47:        : <span class="white">        /// testing is to be carried out.</span>
  48:        : <span class="white">        /// &lt;/param&gt;</span>
  49:        : <span class="white">        /// &lt;param name="module"&gt;</span>
  50:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
  51:        : <span class="white">        /// containing assembly.</span>
  52:        : <span class="white">        /// &lt;/param&gt;</span>
  53:        : <span class="white">        /// &lt;returns&gt;</span>
  54:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
  55:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
  56:        : <span class="white">        /// &lt;/returns&gt;</span>
  57:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)</span>
  58:        : <span class="white">        {</span>
  59:     1/1: <span class="green">            var sequence = new Dictionary&lt;int, OpCode&gt;();</span>
  60:     4/4: <span class="green">            int startIndex = -1;</span>
  61:   27/27: <span class="green">            for (int index = 0; index &lt; method.Body.Instructions.Count; index++)</span>
  62:        : <span class="white">            {</span>
  63:     4/4: <span class="green">                var instruction = method.Body.Instructions[index];</span>
  64:     7/7: <span class="green">                if (instruction.SequencePoint != null)</span>
  65:        : <span class="white">                {</span>
  66:     7/7: <span class="green">                    startIndex = index;</span>
  67:     1/1: <span class="green">                    sequence.Clear();</span>
  68:        : <span class="white">                }</span>
  69:   10/10: <span class="green">                if (startIndex &gt;= 0)</span>
  70:        : <span class="white">                {</span>
  71:     4/4: <span class="green">                    sequence.Add(index, instruction.OpCode);</span>
  72:        : <span class="white">                }</span>
  73:   15/15: <span class="green">                if (index == method.Body.Instructions.Count - 1 || instruction.Next.SequencePoint != null)</span>
  74:        : <span class="white">                {</span>
  75:     9/9: <span class="green">                    if (!ShouldDeleteSequence(method.Body, sequence)) continue;</span>
  76:        : <span class="white"></span>
  77:     4/4: <span class="green">                    OpCode originalOpCode = method.Body.Instructions[startIndex].OpCode;</span>
  78:     4/4: <span class="green">                    object originalOperand = method.Body.Instructions[startIndex].Operand;</span>
  79:     4/4: <span class="green">                    method.Body.Instructions[startIndex].OpCode = OpCodes.Br;</span>
  80:     4/4: <span class="green">                    method.Body.Instructions[startIndex].Operand = instruction.Next;</span>
  81:        : <span class="white"></span>
  82:     5/5: <span class="green">                    var codes = string.Join(", ", sequence.Values.Select(o =&gt; o.Code));</span>
  83:     6/6: <span class="green">                    var description = string.Format("{0:x4}: deleting {1}", GetOriginalOffset(startIndex), codes);</span>
  84:     5/5: <span class="green">                    MutantMetaData mutation = DoYield(method, module, description, startIndex);</span>
  85:   11/11: <span class="green">                    yield return mutation;</span>
  86:        : <span class="white"></span>
  87:     4/4: <span class="green">                    method.Body.Instructions[startIndex].OpCode = originalOpCode;</span>
  88:     4/4: <span class="green">                    method.Body.Instructions[startIndex].Operand = originalOperand;</span>
  89:        : <span class="white">                }</span>
  90:        : <span class="white">            }</span>
  91:     1/1: <span class="green">        }</span>
  92:        : <span class="white"></span>
  93:        : <span class="white">        private bool ShouldDeleteSequence(MethodBody method, IDictionary&lt;int, OpCode&gt; opCodes)</span>
  94:        : <span class="amber">        {</span>
  95:   13/13: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Nop)) return false;</span>
  96:   13/13: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Pop)) return false;</span>
  97:   13/13: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Leave)) return false;</span>
  98:   13/13: <span class="green">            if (opCodes.Values.Any(o =&gt; o == OpCodes.Ret)) return false;</span>
  99:        : <span class="white"></span>
 100:        : <span class="white">            // If just setting compiler-generated return variable in Debug mode, don't delete.</span>
 101:     7/7: <span class="green">            if (opCodes.Values.Last().Code == Code.Br)</span>
 102:        : <span class="amber">            {</span>
 103:   11/11: <span class="green">                if (((Instruction)method.Instructions[opCodes.Keys.Last()].Operand).Offset</span>
 104:   11/11: <span class="green">                    == method.Instructions[opCodes.Keys.Last() + 1].Offset)</span>
 105:        : <span class="amber">                {</span>
 106:   11/11: <span class="green">                    if (method.Instructions[opCodes.Keys.Last() + 2].OpCode == OpCodes.Ret)</span>
 107:        : <span class="amber">                    {</span>
 108:     3/3: <span class="green">                        return false;</span>
 109:        : <span class="white">                    }</span>
 110:        : <span class="amber">                }</span>
 111:        : <span class="amber">            }</span>
 112:        : <span class="white"></span>
 113:        : <span class="white">            // If calling base constructor, don't delete.</span>
 114:   10/10: <span class="green">            if (opCodes.Any(kv =&gt; kv.Value == OpCodes.Call))</span>
 115:        : <span class="amber">            {</span>
 116:   10/10: <span class="green">                if (((MethodReference)method.Instructions[opCodes.First(kv =&gt; kv.Value == OpCodes.Call).Key].Operand).Name == Methods.CONSTRUCTOR)</span>
 117:        : <span class="amber">                {</span>
 118:     3/3: <span class="green">                    return false;</span>
 119:        : <span class="white">                }</span>
 120:        : <span class="amber">            }</span>
 121:        : <span class="white"></span>
 122:     1/1: <span class="green">            return true;</span>
 123:        : <span class="amber">        }</span>
 124:        : <span class="white">    }</span>
 125:        : <span class="white">}</span>
</pre><h1>OpCodeRotationTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System.Collections.Generic;</span>
  23:        : <span class="white"></span>
  24:        : <span class="white">using Mono.Cecil;</span>
  25:        : <span class="white">using Mono.Cecil.Cil;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">namespace NinjaTurtles.Turtles</span>
  28:        : <span class="white">{</span>
  29:        : <span class="white">    /// &lt;summary&gt;</span>
  30:        : <span class="white">    /// An abstract base class for implementations of</span>
  31:        : <span class="white">    /// &lt;see cref="IMethodTurtle" /&gt; that operator by replacing a number of</span>
  32:        : <span class="white">    /// IL OpCodes with a list of replacements in turn.</span>
  33:        : <span class="white">    /// &lt;/summary&gt;</span>
  34:        : <span class="white">    /// &lt;remarks&gt;</span>
  35:        : <span class="white">    /// Classes extending this one only need to set the value of the</span>
  36:        : <span class="white">    /// &lt;see fref="_opCodes" /&gt; field to an appropriate dictionary of source</span>
  37:        : <span class="white">    /// and target OpCodes.</span>
  38:        : <span class="white">    /// &lt;/remarks&gt;</span>
  39:        : <span class="white">    public abstract class OpCodeRotationTurtle : MethodTurtleBase</span>
  40:        : <span class="white">    {</span>
  41:        : <span class="white">        /// &lt;summary&gt;</span>
  42:        : <span class="white">        /// An &lt;see cref="IDictionary{K,V}" /&gt; containing source OpCodes as</span>
  43:        : <span class="white">        /// keys, and &lt;see cref="IEnumerable{T}" /&gt;s of OpCodes as each key's</span>
  44:        : <span class="white">        /// possible replacements.</span>
  45:        : <span class="white">        /// &lt;/summary&gt;</span>
  46:        : <span class="white">        protected IDictionary&lt;OpCode, IEnumerable&lt;OpCode&gt;&gt; _opCodes;</span>
  47:        : <span class="white"></span>
  48:        : <span class="white">        /// &lt;summary&gt;</span>
  49:        : <span class="white">        /// Performs the actual code mutations, returning each with</span>
  50:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.</span>
  51:        : <span class="white">        /// &lt;/summary&gt;</span>
  52:        : <span class="white">        /// &lt;remarks&gt;</span>
  53:        : <span class="white">        /// Implementing classes should yield the result obtained by calling</span>
  54:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.</span>
  55:        : <span class="white">        /// &lt;/remarks&gt;</span>
  56:        : <span class="white">        /// &lt;param name="method"&gt;</span>
  57:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
  58:        : <span class="white">        /// testing is to be carried out.</span>
  59:        : <span class="white">        /// &lt;/param&gt;</span>
  60:        : <span class="white">        /// &lt;param name="module"&gt;</span>
  61:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
  62:        : <span class="white">        /// containing assembly.</span>
  63:        : <span class="white">        /// &lt;/param&gt;</span>
  64:        : <span class="white">        /// &lt;returns&gt;</span>
  65:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
  66:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
  67:        : <span class="white">        /// &lt;/returns&gt;</span>
  68:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)</span>
  69:        : <span class="white">        {</span>
  70:   23/23: <span class="green">            for (int index = 0; index &lt; method.Body.Instructions.Count; index++)</span>
  71:        : <span class="white">            {</span>
  72:     3/3: <span class="green">                var instruction = method.Body.Instructions[index];</span>
  73:     7/7: <span class="green">                if (_opCodes.ContainsKey(instruction.OpCode))</span>
  74:        : <span class="white">                {</span>
  75:     9/9: <span class="green">                    if (instruction.IsMeaninglessUnconditionalBranch()) continue;</span>
  76:        : <span class="white"></span>
  77:     2/2: <span class="green">                    var originalOpCode = instruction.OpCode;</span>
  78:        : <span class="white"></span>
  79:   15/15: <span class="green">                    foreach (var opCode in _opCodes[originalOpCode])</span>
  80:        : <span class="white">                    {</span>
  81:     2/2: <span class="green">                        instruction.OpCode = opCode;</span>
  82:     6/6: <span class="green">                        var description = string.Format("{0:x4}: {1} =&gt; {2}", GetOriginalOffset(index), originalOpCode.Code, opCode.Code);</span>
  83:     3/3: <span class="green">                        MutantMetaData mutation = DoYield(method, module, description, index);</span>
  84:     8/8: <span class="green">                        yield return mutation;</span>
  85:        : <span class="white">                    }</span>
  86:        : <span class="white"></span>
  87:     2/2: <span class="green">                    instruction.OpCode = originalOpCode;</span>
  88:        : <span class="white">                }</span>
  89:        : <span class="white">            }</span>
  90:     2/2: <span class="green">        }</span>
  91:        : <span class="white">    }</span>
  92:        : <span class="white">}</span>
</pre><h1>MethodTurtleBase.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Globalization;</span>
  25:        : <span class="white">using System.IO;</span>
  26:        : <span class="white">using System.Linq;</span>
  27:        : <span class="white"></span>
  28:        : <span class="white">using Mono.Cecil;</span>
  29:        : <span class="white">using Mono.Cecil.Cil;</span>
  30:        : <span class="white">using Mono.Cecil.Rocks;</span>
  31:        : <span class="white"></span>
  32:        : <span class="white">namespace NinjaTurtles.Turtles</span>
  33:        : <span class="white">{</span>
  34:        : <span class="white">    /// &lt;summary&gt;</span>
  35:        : <span class="white">    /// An abstract base class for implementations of</span>
  36:        : <span class="white">    /// &lt;see cref="IMethodTurtle" /&gt;.</span>
  37:        : <span class="white">    /// &lt;/summary&gt;</span>
  38:        : <span class="white">    public abstract class MethodTurtleBase : IMethodTurtle</span>
  39:        : <span class="white">    {</span>
  40:        : <span class="white">        private int[] _originalOffsets;</span>
  41:        : <span class="white">        private Module _module;</span>
  42:        : <span class="white">        private MethodDefinition _method;</span>
  43:        : <span class="white"></span>
  44:        : <span class="white">        internal void MutantComplete(MutantMetaData metaData)</span>
  45:        : <span class="amber">        {</span>
  46:     1/1: <span class="green">            metaData.TestDirectory.Dispose();</span>
  47:        : <span class="amber">        }</span>
  48:        : <span class="white"></span>
  49:        : <span class="white">        /// &lt;summary&gt;</span>
  50:        : <span class="white">        /// Returns an &lt;see cref="IEnumerable{T}" /&gt; of detailed descriptions</span>
  51:        : <span class="white">        /// of mutations, having first carried out the mutation in question and</span>
  52:        : <span class="white">        /// saved the modified assembly under test to disk.</span>
  53:        : <span class="white">        /// &lt;/summary&gt;</span>
  54:        : <span class="white">        /// &lt;param name="method"&gt;</span>
  55:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
  56:        : <span class="white">        /// testing is to be carried out.</span>
  57:        : <span class="white">        /// &lt;/param&gt;</span>
  58:        : <span class="white">        /// &lt;param name="module"&gt;</span>
  59:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
  60:        : <span class="white">        /// containing assembly.</span>
  61:        : <span class="white">        /// &lt;/param&gt;</span>
  62:        : <span class="white">        /// &lt;param name="originalOffsets"&gt;</span>
  63:        : <span class="white">        /// An array of the original IL offsets before macros were expanded.</span>
  64:        : <span class="white">        /// &lt;/param&gt;</span>
  65:        : <span class="white">        /// &lt;returns&gt;</span>
  66:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
  67:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
  68:        : <span class="white">        /// &lt;/returns&gt;</span>
  69:        : <span class="white">        public IEnumerable&lt;MutantMetaData&gt; Mutate(MethodDefinition method, Module module, int[] originalOffsets)</span>
  70:        : <span class="white">        {</span>
  71:     1/1: <span class="green">            _module = module;</span>
  72:     2/2: <span class="green">            _method = method;</span>
  73:     1/1: <span class="green">            _originalOffsets = originalOffsets;</span>
  74:     2/2: <span class="green">            method.Body.SimplifyMacros();</span>
  75:   14/14: <span class="green">            foreach (var mutation in DoMutate(method, module))</span>
  76:        : <span class="white">            {</span>
  77:     8/8: <span class="green">                yield return mutation;</span>
  78:        : <span class="white">            }</span>
  79:     8/8: <span class="green">            if (method.ReturnType.Name == "IEnumerable`1")</span>
  80:        : <span class="white">            {</span>
  81:     5/5: <span class="green">                var nestedType =</span>
  82:     5/5: <span class="green">                    method.DeclaringType.NestedTypes.FirstOrDefault(</span>
  83:     5/5: <span class="green">                        t =&gt; t.Name.StartsWith(string.Format("&lt;{0}&gt;", method.Name))</span>
  84:     5/5: <span class="green">                        &amp;&amp; t.Interfaces.Any(i =&gt; i.Name == "IEnumerable`1"));</span>
  85:     7/7: <span class="green">                if (nestedType != null)</span>
  86:        : <span class="white">                {</span>
  87:     5/5: <span class="green">                    var nestedMethod = nestedType.Methods.FirstOrDefault(m =&gt; m.Name == "MoveNext");</span>
  88:     8/8: <span class="green">                    if (nestedMethod != null)</span>
  89:        : <span class="white">                    {</span>
  90:     5/5: <span class="green">                        _originalOffsets = nestedMethod.Body.Instructions.Select(i =&gt; i.Offset).ToArray();</span>
  91:     2/2: <span class="green">                        _method = nestedMethod;</span>
  92:     2/2: <span class="green">                        nestedMethod.Body.SimplifyMacros();</span>
  93:   14/14: <span class="green">                        foreach (var mutation in DoMutate(nestedMethod, module))</span>
  94:        : <span class="white">                        {</span>
  95:     8/8: <span class="green">                            yield return mutation;</span>
  96:        : <span class="white">                        }</span>
  97:        : <span class="white">                    }</span>
  98:        : <span class="white">                }</span>
  99:        : <span class="white">            }</span>
 100:     2/2: <span class="green">            method.Body.OptimizeMacros();</span>
 101:     2/2: <span class="green">        }</span>
 102:        : <span class="white"></span>
 103:        : <span class="white">        /// &lt;summary&gt;</span>
 104:        : <span class="white">        /// Performs the actual code mutations, returning each with</span>
 105:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.</span>
 106:        : <span class="white">        /// &lt;/summary&gt;</span>
 107:        : <span class="white">        /// &lt;remarks&gt;</span>
 108:        : <span class="white">        /// Implementing classes should yield the result obtained by calling</span>
 109:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.</span>
 110:        : <span class="white">        /// &lt;/remarks&gt;</span>
 111:        : <span class="white">        /// &lt;param name="method"&gt;</span>
 112:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
 113:        : <span class="white">        /// testing is to be carried out.</span>
 114:        : <span class="white">        /// &lt;/param&gt;</span>
 115:        : <span class="white">        /// &lt;param name="module"&gt;</span>
 116:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
 117:        : <span class="white">        /// containing assembly.</span>
 118:        : <span class="white">        /// &lt;/param&gt;</span>
 119:        : <span class="white">        /// &lt;returns&gt;</span>
 120:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of</span>
 121:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.</span>
 122:        : <span class="white">        /// &lt;/returns&gt;</span>
 123:        : <span class="white">        protected abstract IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module);</span>
 124:        : <span class="white"></span>
 125:        : <span class="white">        /// &lt;summary&gt;</span>
 126:        : <span class="white">        /// A helper method that copies the test folder, and saves the mutated</span>
 127:        : <span class="white">        /// assembly under test into it before returning an instance of</span>
 128:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt;.</span>
 129:        : <span class="white">        /// &lt;/summary&gt;</span>
 130:        : <span class="white">        /// &lt;param name="method"&gt;</span>
 131:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation</span>
 132:        : <span class="white">        /// testing is to be carried out.</span>
 133:        : <span class="white">        /// &lt;/param&gt;</span>
 134:        : <span class="white">        /// &lt;param name="module"&gt;</span>
 135:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the</span>
 136:        : <span class="white">        /// containing assembly.</span>
 137:        : <span class="white">        /// &lt;/param&gt;</span>
 138:        : <span class="white">        /// &lt;param name="description"&gt;</span>
 139:        : <span class="white">        /// A description of the mutation that has been applied.</span>
 140:        : <span class="white">        /// &lt;/param&gt;</span>
 141:        : <span class="white">        /// &lt;param name="index"&gt;</span>
 142:        : <span class="white">        /// The index of the (first) IL instruction at which the mutation was</span>
 143:        : <span class="white">        /// applied.</span>
 144:        : <span class="white">        /// &lt;/param&gt;</span>
 145:        : <span class="white">        /// &lt;returns&gt;&lt;/returns&gt;</span>
 146:        : <span class="white">        protected MutantMetaData DoYield(MethodDefinition method, Module module, string description, int index)</span>
 147:        : <span class="amber">        {</span>
 148:     1/1: <span class="green">            var testDirectory = new TestDirectory(Path.GetDirectoryName(module.AssemblyLocation));</span>
 149:     1/1: <span class="green">            testDirectory.SaveAssembly(module);</span>
 150:     7/7: <span class="green">            return new MutantMetaData</span>
 151:     7/7: <span class="green">            {</span>
 152:     7/7: <span class="green">                Description = description,</span>
 153:     7/7: <span class="green">                MethodDefinition = method,</span>
 154:     7/7: <span class="green">                TestDirectory = testDirectory,</span>
 155:     7/7: <span class="green">                ILIndex = index</span>
 156:     7/7: <span class="green">            };</span>
 157:        : <span class="amber">        }</span>
 158:        : <span class="white"></span>
 159:        : <span class="white">        internal int GetOriginalOffset(int index)</span>
 160:        : <span class="white">        {</span>
 161:        : <span class="white">            return _originalOffsets[index];</span>
 162:        : <span class="white">        }</span>
 163:        : <span class="white"></span>
 164:        : <span class="white">        internal string GetOriginalSourceFileName(int index)</span>
 165:        : <span class="white">        {</span>
 166:        : <span class="white">            var sequencePoint = GetCurrentSequencePoint(index);</span>
 167:        : <span class="white">            return Path.GetFileName(sequencePoint.Document.Url);</span>
 168:        : <span class="white">        }</span>
 169:        : <span class="white"></span>
 170:        : <span class="white">        internal SequencePoint GetCurrentSequencePoint(int index)</span>
 171:        : <span class="white">        {</span>
 172:        : <span class="white">            var instruction = _method.Body.Instructions[index];</span>
 173:        : <span class="white">            while ((instruction.SequencePoint == null</span>
 174:        : <span class="white">                || instruction.SequencePoint.StartLine == 0xfeefee) &amp;&amp; index &gt; 0)</span>
 175:        : <span class="white">            {</span>
 176:        : <span class="white">                index--;</span>
 177:        : <span class="white">                instruction = _method.Body.Instructions[index];</span>
 178:        : <span class="white">            }</span>
 179:        : <span class="white">            var sequencePoint = instruction.SequencePoint;</span>
 180:        : <span class="white">            return sequencePoint;</span>
 181:        : <span class="white">        }</span>
 182:        : <span class="white"></span>
 183:        : <span class="white">        internal string GetOriginalSourceCode(int index)</span>
 184:        : <span class="white">        {</span>
 185:        : <span class="white">            var sequencePoint = GetCurrentSequencePoint(index);</span>
 186:        : <span class="white">            string result = "";</span>
 187:        : <span class="white">            string[] sourceCode = _module.SourceFiles[sequencePoint.Document.Url];</span>
 188:        : <span class="white">            int upperBound = Math.Min(sequencePoint.EndLine + 2, sourceCode.Length);</span>
 189:        : <span class="white">            for (int line = Math.Max(sequencePoint.StartLine - 2, 1); line &lt;= upperBound; line++)</span>
 190:        : <span class="white">            {</span>
 191:        : <span class="white">                string sourceLine = sourceCode[line - 1].Replace("\t", "    ");</span>
 192:        : <span class="white">                result += line.ToString(CultureInfo.InvariantCulture)</span>
 193:        : <span class="white">                    .PadLeft(4, ' ') + ": " + sourceLine.TrimEnd(' ', '\t');</span>
 194:        : <span class="white">                if (line &lt; upperBound) result += Environment.NewLine;</span>
 195:        : <span class="white">            }</span>
 196:        : <span class="white">            return result;</span>
 197:        : <span class="white">        }</span>
 198:        : <span class="white">    }</span>
 199:        : <span class="white">}</span>
</pre><h1>TestDirectory.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.IO;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">using NLog;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">namespace NinjaTurtles</span>
  28:        : <span class="white">{</span>
  29:        : <span class="white">    internal class TestDirectory : IDisposable</span>
  30:        : <span class="white">    {</span>
  31:        : <span class="white">        #region Logging</span>
  32:        : <span class="white"></span>
  33:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();</span>
  34:        : <span class="white"></span>
  35:        : <span class="white">        #endregion</span>
  36:        : <span class="white"></span>
  37:        : <span class="white">        private readonly string _folder;</span>
  38:        : <span class="white"></span>
  39:        : <span class="amber">        public TestDirectory()</span>
  40:        : <span class="amber">        {</span>
  41:     1/1: <span class="green">            _folder = Path.Combine(Path.GetTempPath(),</span>
  42:     1/1: <span class="green">                                   "NinjaTurtles",</span>
  43:     1/1: <span class="green">                                   Guid.NewGuid().ToString("N"));</span>
  44:     1/1: <span class="green">            _log.Debug("Creating folder \"{0}\".", _folder);</span>
  45:     1/1: <span class="green">            Directory.CreateDirectory(_folder);</span>
  46:        : <span class="amber">        }</span>
  47:        : <span class="white"></span>
  48:        : <span class="amber">        public TestDirectory(string sourceFolder) : this()</span>
  49:        : <span class="amber">        {</span>
  50:     2/2: <span class="green">            _log.Debug("Copying contents from folder \"{0}\".", sourceFolder);</span>
  51:     3/3: <span class="green">            CopyDirectoryContents(sourceFolder, _folder);</span>
  52:        : <span class="amber">        }</span>
  53:        : <span class="white"></span>
  54:        : <span class="white">        public void SaveAssembly(Module module)</span>
  55:        : <span class="amber">        {</span>
  56:     3/3: <span class="green">            string fileName = Path.GetFileName(module.AssemblyLocation);</span>
  57:     7/7: <span class="green">            string path = Path.Combine(_folder, fileName);</span>
  58:     5/5: <span class="green">            _log.Debug("Writing assembly \"{0}\" to \"{1}\".", fileName, _folder);</span>
  59:     3/3: <span class="green">            module.AssemblyDefinition.Write(path);</span>
  60:        : <span class="amber">        }</span>
  61:        : <span class="white"></span>
  62:        : <span class="white">        private static void CopyDirectoryContents</span>
  63:        : <span class="white">            (string directory, string targetDirectory)</span>
  64:        : <span class="amber">        {</span>
  65:   19/19: <span class="green">            foreach (var file in Directory.GetFiles(directory))</span>
  66:        : <span class="amber">            {</span>
  67:   11/11: <span class="green">                string fileName = Path.GetFileName(file);</span>
  68:     7/7: <span class="green">                _log.Trace("Copying file \"{0}\".", fileName);</span>
  69:   17/17: <span class="green">                string target = Path.Combine(targetDirectory, fileName);</span>
  70:   13/13: <span class="green">                File.Copy(file, target);</span>
  71:     5/5: <span class="green">            }</span>
  72:   19/19: <span class="green">            foreach (var subDirectory in Directory.GetDirectories(directory))</span>
  73:        : <span class="amber">            {</span>
  74:   11/11: <span class="green">                string subDirectoryName = Path.GetFileName(subDirectory);</span>
  75:     7/7: <span class="green">                _log.Trace("Creating subdirectory \"{0}\".", subDirectoryName);</span>
  76:   17/17: <span class="green">                string target = Path.Combine(targetDirectory, subDirectoryName);</span>
  77:     7/7: <span class="green">                Directory.CreateDirectory(target);</span>
  78:   13/13: <span class="green">                CopyDirectoryContents(subDirectory, target);</span>
  79:     5/5: <span class="green">            }</span>
  80:        : <span class="amber">        }</span>
  81:        : <span class="white"></span>
  82:        : <span class="white">        public string FullName</span>
  83:        : <span class="white">        {</span>
  84:        : <span class="white">            get { return _folder; }</span>
  85:        : <span class="white">        }</span>
  86:        : <span class="white"></span>
  87:        : <span class="white">        public void Dispose()</span>
  88:        : <span class="amber">        {</span>
  89:     5/5: <span class="green">            if (DoNotDelete)</span>
  90:        : <span class="amber">            {</span>
  91:     2/2: <span class="green">                return;</span>
  92:        : <span class="white">            }</span>
  93:        : <span class="white">            try</span>
  94:        : <span class="amber">            {</span>
  95:     2/2: <span class="green">                _log.Debug("Deleting folder \"{0}\".", _folder);</span>
  96:     2/2: <span class="green">                Directory.Delete(_folder, true);</span>
  97:        : <span class="amber">            }</span>
  98:     1/1: <span class="green">            catch (Exception ex)</span>
  99:        : <span class="amber">            {</span>
 100:     3/3: <span class="green">                string message = string.Format("Failed to delete folder \"{0}\".", _folder);</span>
 101:     2/2: <span class="green">                _log.ErrorException(message, ex);</span>
 102:        : <span class="amber">            }</span>
 103:        : <span class="amber">        }</span>
 104:        : <span class="white"></span>
 105:        : <span class="white">        public bool DoNotDelete { get; set; }</span>
 106:        : <span class="white">    }</span>
 107:        : <span class="white">}</span>
 108:        : <span class="white"></span>
</pre><h1>MutationTest.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Diagnostics;</span>
  25:        : <span class="white">using System.IO;</span>
  26:        : <span class="white">using System.Linq;</span>
  27:        : <span class="white">using System.Management;</span>
  28:        : <span class="white">using System.Threading;</span>
  29:        : <span class="white">using System.Threading.Tasks;</span>
  30:        : <span class="white">using System.Xml.Serialization;</span>
  31:        : <span class="white"></span>
  32:        : <span class="white">using Microsoft.Win32;</span>
  33:        : <span class="white"></span>
  34:        : <span class="white">using Mono.Cecil;</span>
  35:        : <span class="white"></span>
  36:        : <span class="white">using NinjaTurtles.Reporting;</span>
  37:        : <span class="white">using NinjaTurtles.TestRunners;</span>
  38:        : <span class="white">using NinjaTurtles.Turtles;</span>
  39:        : <span class="white"></span>
  40:        : <span class="white">namespace NinjaTurtles</span>
  41:        : <span class="white">{</span>
  42:        : <span class="white">    internal class MutationTest : IMutationTest</span>
  43:        : <span class="white">    {</span>
  44:        : <span class="white">        private const string ERROR_REPORTING_KEY = @"SOFTWARE\Microsoft\Windows\Windows Error Reporting";</span>
  45:        : <span class="white">        private const string ERROR_REPORTING_VALUE = "DontShowUI";</span>
  46:        : <span class="white"></span>
  47:        : <span class="white">        private readonly IList&lt;Type&gt; _mutationsToApply = new List&lt;Type&gt;();</span>
  48:        : <span class="white">        private readonly string _testAssemblyLocation;</span>
  49:        : <span class="white">        private readonly Type[] _parameterTypes;</span>
  50:        : <span class="white">        private readonly AssemblyDefinition _testAssembly;</span>
  51:        : <span class="white">        private readonly TypeReference _targetTypeReference;</span>
  52:        : <span class="white">        private Module _module;</span>
  53:        : <span class="white">        private IEnumerable&lt;string&gt; _testsToRun;</span>
  54:        : <span class="white">        private ITestRunner _runner;</span>
  55:        : <span class="white">        private MutationTestingReport _report;</span>
  56:        : <span class="white">        private ReportingStrategy _reportingStrategy = new NullReportingStrategy();</span>
  57:        : <span class="white">        private string _reportFileName;</span>
  58:        : <span class="white"></span>
  59:        : <span class="white">        internal MutationTest(string testAssemblyLocation, Type targetType, string targetMethod, Type[] parameterTypes)</span>
  60:        : <span class="white">        {</span>
  61:        : <span class="white">            TargetType = targetType;</span>
  62:        : <span class="white">            TargetMethod = targetMethod;</span>
  63:        : <span class="white">            _testAssemblyLocation = testAssemblyLocation;</span>
  64:        : <span class="white">            _parameterTypes = parameterTypes;</span>
  65:        : <span class="white">            _testAssembly = AssemblyDefinition.ReadAssembly(testAssemblyLocation);</span>
  66:        : <span class="white">            _targetTypeReference = _testAssembly.MainModule.Import(targetType);</span>
  67:        : <span class="white">        }</span>
  68:        : <span class="white"></span>
  69:        : <span class="white">        public Type TargetType { get; private set; }</span>
  70:        : <span class="white"></span>
  71:        : <span class="white">        public string TargetMethod { get; private set; }</span>
  72:        : <span class="white"></span>
  73:        : <span class="white">        public void Run()</span>
  74:        : <span class="amber">        {</span>
  75:     1/1: <span class="green">            var key = Registry.LocalMachine.OpenSubKey(ERROR_REPORTING_KEY, RegistryKeyPermissionCheck.ReadWriteSubTree);</span>
  76:     1/1: <span class="green">            var errorReportingValue = key.GetValue(ERROR_REPORTING_VALUE, null);</span>
  77:     1/1: <span class="green">            key.SetValue(ERROR_REPORTING_VALUE, 1, RegistryValueKind.DWord);</span>
  78:     1/1: <span class="green">            key.Close();</span>
  79:        : <span class="white"></span>
  80:     1/1: <span class="green">            MethodDefinition method = ValidateMethod();</span>
  81:     1/1: <span class="green">            _module.LoadDebugInformation();</span>
  82:     4/4: <span class="green">            int[] originalOffsets = method.Body.Instructions.Select(i =&gt; i.Offset).ToArray();</span>
  83:     1/1: <span class="green">            _report = new MutationTestingReport();</span>
  84:     1/1: <span class="green">            _testsToRun = GetMatchingTestsOrFail(method);</span>
  85:     1/1: <span class="green">            int count = 0;</span>
  86:     1/1: <span class="green">            int failures = 0;</span>
  87:     6/6: <span class="green">            if (_mutationsToApply.Count == 0) PopulateDefaultTurtles();</span>
  88:   13/13: <span class="green">            foreach (var turtleType in _mutationsToApply)</span>
  89:        : <span class="amber">            {</span>
  90:     1/1: <span class="green">                var turtle = (MethodTurtleBase)Activator.CreateInstance(turtleType);</span>
  91:     1/1: <span class="green">                Parallel.ForEach(turtle.Mutate(method, _module, originalOffsets),</span>
  92:     1/1: <span class="green">                    mutation =&gt; RunMutation(turtle, mutation, ref failures, ref count));</span>
  93:        : <span class="amber">            }</span>
  94:        : <span class="white"></span>
  95:     1/1: <span class="green">            _report.RegisterMethod(method);</span>
  96:     1/1: <span class="green">            _reportingStrategy.WriteReport(_report, _reportFileName);</span>
  97:        : <span class="white"></span>
  98:     1/1: <span class="green">            key = Registry.LocalMachine.OpenSubKey(ERROR_REPORTING_KEY, RegistryKeyPermissionCheck.ReadWriteSubTree);</span>
  99:     5/5: <span class="green">            if (errorReportingValue == null)</span>
 100:        : <span class="amber">            {</span>
 101:     1/1: <span class="green">                key.DeleteValue(ERROR_REPORTING_VALUE);</span>
 102:     2/2: <span class="green">            }</span>
 103:        : <span class="white">            else</span>
 104:        : <span class="amber">            {</span>
 105:     1/1: <span class="green">                key.SetValue(ERROR_REPORTING_VALUE, errorReportingValue, RegistryValueKind.DWord);</span>
 106:        : <span class="amber">            }</span>
 107:     1/1: <span class="green">            key.Close();</span>
 108:        : <span class="white"></span>
 109:     5/5: <span class="green">            if (count == 0)</span>
 110:        : <span class="amber">            {</span>
 111:     1/1: <span class="green">                Console.WriteLine("No valid mutations found (this is fine).");</span>
 112:     2/2: <span class="green">                return;</span>
 113:        : <span class="white">            }</span>
 114:     5/5: <span class="green">            if (failures &gt; 0)</span>
 115:        : <span class="amber">            {</span>
 116:     1/1: <span class="green">                throw new MutationTestFailureException();</span>
 117:        : <span class="white">            }</span>
 118:        : <span class="amber">        }</span>
 119:        : <span class="white"></span>
 120:        : <span class="white">        private void RunMutation(MethodTurtleBase turtle, MutantMetaData mutation, ref int failures, ref int count)</span>
 121:        : <span class="amber">        {</span>
 122:     2/2: <span class="green">            bool testProcessFailed = CheckTestProcessFails(turtle, mutation);</span>
 123:     8/8: <span class="green">            if (!testProcessFailed)</span>
 124:        : <span class="amber">            {</span>
 125:     1/1: <span class="green">                Interlocked.Increment(ref failures);</span>
 126:        : <span class="amber">            }</span>
 127:     1/1: <span class="green">            Interlocked.Increment(ref count);</span>
 128:        : <span class="amber">        }</span>
 129:        : <span class="white"></span>
 130:        : <span class="white">        private bool CheckTestProcessFails(MethodTurtleBase turtle, MutantMetaData mutation)</span>
 131:        : <span class="amber">        {</span>
 132:   12/12: <span class="green">            if (_runner == null) _runner = (ITestRunner)Activator.CreateInstance(MutationTestBuilder.TestRunner);</span>
 133:     2/2: <span class="green">            var process = _runner.GetRunnerProcess(mutation, _testAssemblyLocation, _testsToRun);</span>
 134:        : <span class="white"></span>
 135:     1/1: <span class="green">            process.Start();</span>
 136:     4/4: <span class="green">            bool exitedInTime = process.WaitForExit(30000);</span>
 137:     1/1: <span class="green">            int exitCode = -1;</span>
 138:        : <span class="white"></span>
 139:        : <span class="white">            try</span>
 140:        : <span class="amber">            {</span>
 141:   14/14: <span class="green">                if (!exitedInTime)</span>
 142:        : <span class="amber">                {</span>
 143:     1/1: <span class="green">                    KillProcessAndChildren(process.Id);</span>
 144:        : <span class="amber">                }</span>
 145:     1/1: <span class="green">                exitCode = process.ExitCode;</span>
 146:        : <span class="amber">            }</span>
 147:        : <span class="amber">            catch {}</span>
 148:        : <span class="white"></span>
 149:   11/11: <span class="green">            bool testSuitePassed = exitCode == 0 &amp;&amp; exitedInTime;</span>
 150:        : <span class="white"></span>
 151:     9/9: <span class="green">            string result = string.Format("Mutant: {0}. {1}",</span>
 152:     9/9: <span class="green">                              mutation.Description,</span>
 153:     9/9: <span class="green">                              testSuitePassed</span>
 154:     9/9: <span class="green">                                  ? "Survived."</span>
 155:     9/9: <span class="green">                                : "Killed.");</span>
 156:     4/4: <span class="green">            _report.AddResult(turtle.GetCurrentSequencePoint(mutation.ILIndex), mutation, !testSuitePassed);</span>
 157:        : <span class="white"></span>
 158:   14/14: <span class="green">            if (testSuitePassed)</span>
 159:        : <span class="amber">            {</span>
 160:     1/1: <span class="green">                mutation.TestDirectory.DoNotDelete = true;</span>
 161:     3/3: <span class="green">                result = string.Format("{0}\nOriginal source code around surviving mutant (in {1}):\n{2}\nFiles left for inspection in: {3}",</span>
 162:     3/3: <span class="green">                    result,</span>
 163:     3/3: <span class="green">                    turtle.GetOriginalSourceFileName(mutation.ILIndex),</span>
 164:     3/3: <span class="green">                    turtle.GetOriginalSourceCode(mutation.ILIndex),</span>
 165:     3/3: <span class="green">                    mutation.TestDirectoryName);</span>
 166:        : <span class="amber">            }</span>
 167:        : <span class="white"></span>
 168:     2/2: <span class="green">            Console.WriteLine(result);</span>
 169:        : <span class="white"></span>
 170:     1/1: <span class="green">            turtle.MutantComplete(mutation);</span>
 171:     6/6: <span class="green">            return !testSuitePassed;</span>
 172:        : <span class="amber">        }</span>
 173:        : <span class="white"></span>
 174:        : <span class="white">        private void KillProcessAndChildren(int pid)</span>
 175:        : <span class="white">        {</span>
 176:        : <span class="white">            using (var searcher = new ManagementObjectSearcher("Select * From Win32_Process Where ParentProcessID=" + pid))</span>
 177:        : <span class="white">            using (ManagementObjectCollection moc = searcher.Get())</span>
 178:        : <span class="white">            {</span>
 179:        : <span class="white">                foreach (ManagementObject mo in moc)</span>
 180:        : <span class="white">                {</span>
 181:        : <span class="white">                    KillProcessAndChildren(Convert.ToInt32(mo["ProcessID"]));</span>
 182:        : <span class="white">                }</span>
 183:        : <span class="white">                try</span>
 184:        : <span class="white">                {</span>
 185:        : <span class="white">                    Process proc = Process.GetProcessById(pid);</span>
 186:        : <span class="white">                    proc.Kill();</span>
 187:        : <span class="white">                }</span>
 188:        : <span class="white">                catch (ArgumentException) {}</span>
 189:        : <span class="white">            }</span>
 190:        : <span class="white">        }</span>
 191:        : <span class="white"></span>
 192:        : <span class="white"></span>
 193:        : <span class="white">        private void PopulateDefaultTurtles()</span>
 194:        : <span class="white">        {</span>
 195:        : <span class="white">            foreach (var type in GetType().Assembly.GetTypes()</span>
 196:        : <span class="white">                .Where(t =&gt; t.GetInterface("IMethodTurtle") != null</span>
 197:        : <span class="white">                &amp;&amp; !t.IsAbstract))</span>
 198:        : <span class="white">            {</span>
 199:        : <span class="white">                _mutationsToApply.Add(type);</span>
 200:        : <span class="white">            }</span>
 201:        : <span class="white">        }</span>
 202:        : <span class="white"></span>
 203:        : <span class="white">        private IEnumerable&lt;string&gt; GetMatchingTestsOrFail(MethodDefinition targetMethod)</span>
 204:        : <span class="white">        {</span>
 205:        : <span class="white">            var tests = new List&lt;string&gt;();</span>
 206:        : <span class="white">            foreach (var type in _testAssembly.MainModule.Types)</span>
 207:        : <span class="white">            {</span>
 208:        : <span class="white">                foreach (var method in type.Methods)</span>
 209:        : <span class="white">                {</span>
 210:        : <span class="white">                    if (method.CustomAttributes</span>
 211:        : <span class="white">                            .Any(a =&gt; HasMatchingMethodTestedAttribute(targetMethod, a)))</span>
 212:        : <span class="white">                    {</span>
 213:        : <span class="white">                        tests.Add(string.Format ("{0}.{1}", type.FullName, method.Name));</span>
 214:        : <span class="white">                    }</span>
 215:        : <span class="white"></span>
 216:        : <span class="white">                }</span>
 217:        : <span class="white">            }</span>
 218:        : <span class="white">            if (!tests.Any())</span>
 219:        : <span class="white">            {</span>
 220:        : <span class="white">                throw new MutationTestFailureException(</span>
 221:        : <span class="white">                    "No matching tests were found to run.");</span>
 222:        : <span class="white">            }</span>
 223:        : <span class="white">            return tests;</span>
 224:        : <span class="white">        }</span>
 225:        : <span class="white"></span>
 226:        : <span class="white">        private bool HasMatchingMethodTestedAttribute(MethodDefinition targetMethod, CustomAttribute attribute)</span>
 227:        : <span class="white">        {</span>
 228:        : <span class="white">            if (attribute.AttributeType.Name != "MethodTestedAttribute") return false;</span>
 229:        : <span class="white">            if ((string)attribute.ConstructorArguments[1].Value != targetMethod.Name) return false;</span>
 230:        : <span class="white">            if (attribute.ConstructorArguments[0].Value is string</span>
 231:        : <span class="white">                &amp;&amp; (string)attribute.ConstructorArguments[0].Value != _targetTypeReference.FullName)</span>
 232:        : <span class="white">            {</span>
 233:        : <span class="white">                return false;</span>
 234:        : <span class="white">            }</span>
 235:        : <span class="white">            if (attribute.ConstructorArguments[0].Value is TypeReference</span>
 236:        : <span class="white">                &amp;&amp; ((TypeReference)attribute.ConstructorArguments[0].Value).FullName != _targetTypeReference.FullName)</span>
 237:        : <span class="white">            {</span>
 238:        : <span class="white">                return false;</span>
 239:        : <span class="white">            }</span>
 240:        : <span class="white">            if (_parameterTypes != null</span>
 241:        : <span class="white">                &amp;&amp; attribute.HasProperties</span>
 242:        : <span class="white">                &amp;&amp; attribute.Properties.Any(p =&gt; p.Name == "ParameterTypes")</span>
 243:        : <span class="white">                &amp;&amp; !Enumerable.SequenceEqual(</span>
 244:        : <span class="white">                    _parameterTypes.Select(t =&gt; t.Name),</span>
 245:        : <span class="white">                    Array.ConvertAll((CustomAttributeArgument[])attribute.Properties.Single(p =&gt; p.Name == "ParameterTypes").Argument.Value, a =&gt; (TypeReference)a.Value)</span>
 246:        : <span class="white">                        .Select(t =&gt; t.Name)))</span>
 247:        : <span class="white">            {</span>
 248:        : <span class="white">                return false;</span>
 249:        : <span class="white">            }</span>
 250:        : <span class="white">            return true;</span>
 251:        : <span class="white">        }</span>
 252:        : <span class="white"></span>
 253:        : <span class="white">        private MethodDefinition ValidateMethod()</span>
 254:        : <span class="white">        {</span>
 255:        : <span class="white">            _module = new Module(TargetType.Assembly.Location);</span>
 256:        : <span class="white">            var type = _module.Definition.Types</span>
 257:        : <span class="white">                .Single(t =&gt; t.FullName == TargetType.FullName);</span>
 258:        : <span class="white">            return MethodDefinitionResolver.ResolveMethod(type, TargetMethod, _parameterTypes);</span>
 259:        : <span class="white">        }</span>
 260:        : <span class="white"></span>
 261:        : <span class="white">        public IMutationTest With&lt;T&gt;() where T : IMethodTurtle</span>
 262:        : <span class="white">        {</span>
 263:        : <span class="white">            _mutationsToApply.Add(typeof(T));</span>
 264:        : <span class="white">            return this;</span>
 265:        : <span class="white">        }</span>
 266:        : <span class="white"></span>
 267:        : <span class="white">        /// &lt;summary&gt;</span>
 268:        : <span class="white">        /// Sets the unit test runner to be used, which is an implementation of</span>
 269:        : <span class="white">        /// &lt;see cref="ITestRunner" /&gt;. If none is specified, then the default</span>
 270:        : <span class="white">        /// is to use &lt;see cref="NUnitTestRunner" /&gt;.</span>
 271:        : <span class="white">        /// &lt;/summary&gt;</span>
 272:        : <span class="white">        /// &lt;typeparam name="T"&gt;</span>
 273:        : <span class="white">        /// A type that implements &lt;see cref="ITestRunner" /&gt;.</span>
 274:        : <span class="white">        /// &lt;/typeparam&gt;</span>
 275:        : <span class="white">        /// &lt;returns&gt;</span>
 276:        : <span class="white">        /// The original &lt;see cref="IMutationTest" /&gt; instance to allow fluent</span>
 277:        : <span class="white">        /// method chaining.</span>
 278:        : <span class="white">        /// &lt;/returns&gt;</span>
 279:        : <span class="white">        public IMutationTest UsingRunner&lt;T&gt;() where T : ITestRunner, new()</span>
 280:        : <span class="white">        {</span>
 281:        : <span class="white">            _runner = new T();</span>
 282:        : <span class="white">            return this;</span>
 283:        : <span class="white">        }</span>
 284:        : <span class="white"></span>
 285:        : <span class="white">        public IMutationTest WriteReportTo(string fileName)</span>
 286:        : <span class="white">        {</span>
 287:        : <span class="white">            _reportingStrategy = new OverwriteReportingStrategy();</span>
 288:        : <span class="white">            _reportFileName = fileName;</span>
 289:        : <span class="white">            return this;</span>
 290:        : <span class="white">        }</span>
 291:        : <span class="white"></span>
 292:        : <span class="white">        public IMutationTest MergeReportTo(string fileName)</span>
 293:        : <span class="white">        {</span>
 294:        : <span class="white">            _reportingStrategy = new MergeReportingStrategy();</span>
 295:        : <span class="white">            _reportFileName = fileName;</span>
 296:        : <span class="white">            return this;</span>
 297:        : <span class="white">        }</span>
 298:        : <span class="white"></span>
 299:        : <span class="white">        private abstract class ReportingStrategy</span>
 300:        : <span class="white">        {</span>
 301:        : <span class="white">            public abstract void WriteReport(MutationTestingReport report, string fileName);</span>
 302:        : <span class="white">        }</span>
 303:        : <span class="white"></span>
 304:        : <span class="white">        private class NullReportingStrategy : ReportingStrategy</span>
 305:        : <span class="white">        {</span>
 306:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName) { }</span>
 307:        : <span class="white">        }</span>
 308:        : <span class="white"></span>
 309:        : <span class="white">        private class OverwriteReportingStrategy : ReportingStrategy</span>
 310:        : <span class="white">        {</span>
 311:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName)</span>
 312:        : <span class="white">            {</span>
 313:        : <span class="white">                using (var streamWriter = File.CreateText(fileName))</span>
 314:        : <span class="white">                {</span>
 315:        : <span class="white">                    new XmlSerializer(typeof(MutationTestingReport)).Serialize(streamWriter, report);</span>
 316:        : <span class="white">                }</span>
 317:        : <span class="white">            }</span>
 318:        : <span class="white">        }</span>
 319:        : <span class="white"></span>
 320:        : <span class="white">        private class MergeReportingStrategy : ReportingStrategy</span>
 321:        : <span class="white">        {</span>
 322:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName)</span>
 323:        : <span class="white">            {</span>
 324:        : <span class="white">                report.MergeFromFile(fileName);</span>
 325:        : <span class="white">                using (var streamWriter = File.CreateText(fileName))</span>
 326:        : <span class="white">                {</span>
 327:        : <span class="white">                    new XmlSerializer(typeof(MutationTestingReport)).Serialize(streamWriter, report);</span>
 328:        : <span class="white">                }</span>
 329:        : <span class="white">            }</span>
 330:        : <span class="white">        }</span>
 331:        : <span class="white">    }</span>
 332:        : <span class="white">}</span>
 333:        : <span class="white"></span>
</pre><h1>MutationTestBuilder.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Reflection;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">using NinjaTurtles.TestRunners;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">namespace NinjaTurtles</span>
  28:        : <span class="white">{</span>
  29:        : <span class="white">    /// &lt;summary&gt;</span>
  30:        : <span class="white">    /// A static class used as the starting point for a fluent definition of</span>
  31:        : <span class="white">    /// a set of mutation tests.</span>
  32:        : <span class="white">    /// &lt;/summary&gt;</span>
  33:        : <span class="white">    /// &lt;typeparam name="T"&gt;</span>
  34:        : <span class="white">    /// The type to be tested.</span>
  35:        : <span class="white">    /// &lt;/typeparam&gt;</span>
  36:        : <span class="white">    /// &lt;example&gt;</span>
  37:        : <span class="white">    /// &lt;para&gt;</span>
  38:        : <span class="white">    /// This code creates and runs the default set of mutation tests for the</span>
  39:        : <span class="white">    /// &lt;b&gt;ClassUnderTest&lt;/b&gt; class's &lt;b&gt;MethodUnderTest&lt;/b&gt; method:</span>
  40:        : <span class="white">    /// &lt;/para&gt;</span>
  41:        : <span class="white">    /// &lt;code lang="cs"&gt;</span>
  42:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest&amp;gt;</span>
  43:        : <span class="white">    ///     .For("MethodUnderTest")</span>
  44:        : <span class="white">    ///     .Run();</span>
  45:        : <span class="white">    /// &lt;/code&gt;</span>
  46:        : <span class="white">    /// &lt;code lang="vbnet"&gt;</span>
  47:        : <span class="white">    /// Call MutationTestBuilder(Of ClassUnderTest) _</span>
  48:        : <span class="white">    ///     .For("MethodUnderTest") _</span>
  49:        : <span class="white">    ///     .Run</span>
  50:        : <span class="white">    /// &lt;/code&gt;</span>
  51:        : <span class="white">    /// &lt;code lang="cpp"&gt;</span>
  52:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest^&amp;gt;</span>
  53:        : <span class="white">    ///     ::For("MethodUnderTest")</span>
  54:        : <span class="white">    ///     -&gt;Run();</span>
  55:        : <span class="white">    /// &lt;/code&gt;</span>
  56:        : <span class="white">    /// &lt;para&gt;</span>
  57:        : <span class="white">    /// When this code is included in a test, it causes the matching tests to</span>
  58:        : <span class="white">    /// be run for each mutation that is found of the code under test. By</span>
  59:        : <span class="white">    /// default, NinjaTurtles assumes it is running under NUnit, and thus uses</span>
  60:        : <span class="white">    /// an NUnit runner to run the suite against the mutated code. This can be</span>
  61:        : <span class="white">    /// changed using the fluent interface:</span>
  62:        : <span class="white">    /// &lt;/para&gt;</span>
  63:        : <span class="white">    /// &lt;code lang="cs"&gt;</span>
  64:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest&amp;gt;</span>
  65:        : <span class="white">    ///     .For("MethodUnderTest")</span>
  66:        : <span class="white">    ///     .UsingRunner&amp;lt;GallioTestRunner&amp;gt;()</span>
  67:        : <span class="white">    ///     .Run();</span>
  68:        : <span class="white">    /// &lt;/code&gt;</span>
  69:        : <span class="white">    /// &lt;code lang="vbnet"&gt;</span>
  70:        : <span class="white">    /// Call MutationTestBuilder(Of ClassUnderTest) _</span>
  71:        : <span class="white">    ///     .For("MethodUnderTest") _</span>
  72:        : <span class="white">    ///     .UsingRunner(Of GallioTestRunner)() _</span>
  73:        : <span class="white">    ///     .Run</span>
  74:        : <span class="white">    /// &lt;/code&gt;</span>
  75:        : <span class="white">    /// &lt;code lang="cpp"&gt;</span>
  76:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest^&amp;gt;</span>
  77:        : <span class="white">    ///     ::For("MethodUnderTest")</span>
  78:        : <span class="white">    ///     -&gt;UsingRunner&amp;lt;GallioTestRunner^&amp;gt;()</span>
  79:        : <span class="white">    ///     -&gt;Run();</span>
  80:        : <span class="white">    /// &lt;/code&gt;</span>
  81:        : <span class="white">    /// &lt;para&gt;</span>
  82:        : <span class="white">    /// Alternatively, this option can be set across all tests in a fixture by</span>
  83:        : <span class="white">    /// including this line in the test fixture's setup method:</span>
  84:        : <span class="white">    /// &lt;/para&gt;</span>
  85:        : <span class="white">    /// &lt;code lang="cs"&gt;</span>
  86:        : <span class="white">    /// MutationTestBuilder.UseRunner&amp;lt;GallioTestRunner&amp;gt;();</span>
  87:        : <span class="white">    /// &lt;/code&gt;</span>
  88:        : <span class="white">    /// &lt;code lang="vbnet"&gt;</span>
  89:        : <span class="white">    /// Call MutationTestBuilder.UseRunner(Of GallioTestRunner)</span>
  90:        : <span class="white">    /// &lt;/code&gt;</span>
  91:        : <span class="white">    /// &lt;code lang="cpp"&gt;</span>
  92:        : <span class="white">    /// MutationTestBuilder::UseRunner&amp;lt;GallioTestRunner^&amp;gt;();</span>
  93:        : <span class="white">    /// &lt;/code&gt;</span>
  94:        : <span class="white">    /// &lt;/example&gt;</span>
  95:        : <span class="white">    public sealed class MutationTestBuilder&lt;T&gt;</span>
  96:        : <span class="white">    {</span>
  97:        : <span class="white">        /// &lt;summary&gt;</span>
  98:        : <span class="white">        /// Returns an &lt;see cref="IMutationTest" /&gt; instance allowing a fluent</span>
  99:        : <span class="white">        /// definition of a set of mutation tests for a particular method.</span>
 100:        : <span class="white">        /// &lt;/summary&gt;</span>
 101:        : <span class="white">        /// &lt;param name="targetMethod"&gt;</span>
 102:        : <span class="white">        /// The name of the method to mutate.</span>
 103:        : <span class="white">        /// &lt;/param&gt;</span>
 104:        : <span class="white">        /// &lt;param name="parameterTypes"&gt;</span>
 105:        : <span class="white">        /// Optional parameter specifying an array of parameter types used to</span>
 106:        : <span class="white">        /// identify a particular method overload.</span>
 107:        : <span class="white">        /// &lt;/param&gt;</span>
 108:        : <span class="white">        /// &lt;returns&gt;</span>
 109:        : <span class="white">        /// An &lt;see cref="IMutationTest" /&gt; instance to allow fluent</span>
 110:        : <span class="white">        /// method chaining.</span>
 111:        : <span class="white">        /// &lt;/returns&gt;</span>
 112:        : <span class="white">        public static IMutationTest For(string targetMethod, Type[] parameterTypes = null)</span>
 113:        : <span class="white">        {</span>
 114:        : <span class="white">            var callingAssembly = Assembly.GetCallingAssembly();</span>
 115:        : <span class="white">            return MutationTestBuilder.For(callingAssembly.Location, typeof(T), targetMethod, parameterTypes);</span>
 116:        : <span class="white">        }</span>
 117:        : <span class="white">    }</span>
 118:        : <span class="white"></span>
 119:        : <span class="white">    /// &lt;summary&gt;</span>
 120:        : <span class="white">    /// A static class used as the starting point for a fluent definition of</span>
 121:        : <span class="white">    /// a set of mutation tests.</span>
 122:        : <span class="white">    /// &lt;/summary&gt;</span>
 123:        : <span class="white">    /// &lt;remarks&gt;</span>
 124:        : <span class="white">    /// For public classes, the generic &lt;see cref="MutationTestBuilder{T}" /&gt;</span>
 125:        : <span class="white">    /// is to be prefered. See that class for full documentation.</span>
 126:        : <span class="white">    /// &lt;/remarks&gt;</span>
 127:        : <span class="white">    public sealed class MutationTestBuilder</span>
 128:        : <span class="white">    {</span>
 129:        : <span class="white">        internal static Type TestRunner { get; set; }</span>
 130:        : <span class="white"></span>
 131:        : <span class="white">        static MutationTestBuilder()</span>
 132:        : <span class="white">        {</span>
 133:        : <span class="white">            TestRunner = typeof(NUnitTestRunner);</span>
 134:        : <span class="white">        }</span>
 135:        : <span class="white"></span>
 136:        : <span class="white">        /// &lt;summary&gt;</span>
 137:        : <span class="white">        /// Returns an &lt;see cref="IMutationTest" /&gt; instance allowing a fluent</span>
 138:        : <span class="white">        /// definition of a set of mutation tests for a particular method.</span>
 139:        : <span class="white">        /// &lt;/summary&gt;</span>
 140:        : <span class="white">        /// &lt;param name="targetClass"&gt;</span>
 141:        : <span class="white">        /// The namespace-qualified name of the type for which mutation tests</span>
 142:        : <span class="white">        /// are being defined.</span>
 143:        : <span class="white">        /// &lt;/param&gt;</span>
 144:        : <span class="white">        /// &lt;param name="targetMethod"&gt;</span>
 145:        : <span class="white">        /// The name of the method to mutate.</span>
 146:        : <span class="white">        /// &lt;/param&gt;</span>
 147:        : <span class="white">        /// &lt;param name="parameterTypes"&gt;</span>
 148:        : <span class="white">        /// Optional parameter specifying an array of parameter types used to</span>
 149:        : <span class="white">        /// identify a particular method overload.</span>
 150:        : <span class="white">        /// &lt;/param&gt;</span>
 151:        : <span class="white">        /// &lt;returns&gt;</span>
 152:        : <span class="white">        /// An &lt;see cref="IMutationTest" /&gt; instance to allow fluent</span>
 153:        : <span class="white">        /// method chaining.</span>
 154:        : <span class="white">        /// &lt;/returns&gt;</span>
 155:        : <span class="white">        public static IMutationTest For(string targetClass, string targetMethod, Type[] parameterTypes = null)</span>
 156:        : <span class="amber">        {</span>
 157:     1/1: <span class="green">            var callingAssembly = Assembly.GetCallingAssembly();</span>
 158:     2/2: <span class="green">            Type resolvedType = TypeResolver.ResolveTypeFromReferences(callingAssembly, targetClass);</span>
 159:        : <span class="white"></span>
 160:     1/1: <span class="green">            return For(callingAssembly.Location, resolvedType, targetMethod, parameterTypes);</span>
 161:        : <span class="amber">        }</span>
 162:        : <span class="white"></span>
 163:        : <span class="white">        internal static IMutationTest For(string callingAssemblyLocation, Type targetType, string targetMethod, Type[] parameterTypes)</span>
 164:        : <span class="white">        {</span>
 165:        : <span class="white">            return new MutationTest(callingAssemblyLocation, targetType, targetMethod, parameterTypes);</span>
 166:        : <span class="white">        }</span>
 167:        : <span class="white"></span>
 168:        : <span class="white">        /// &lt;summary&gt;</span>
 169:        : <span class="white">        /// Specifies the implementation of &lt;see cref="ITestRunner" /&gt; to be</span>
 170:        : <span class="white">        /// used to run the test suite for each mutant. By default, this will</span>
 171:        : <span class="white">        /// be the &lt;see cref="NUnitTestRunner" /&gt;. This can still be overridden</span>
 172:        : <span class="white">        /// on a per-test basis using the</span>
 173:        : <span class="white">        /// &lt;see mref="IMutationTest.UsingRunner" /&gt; method.</span>
 174:        : <span class="white">        /// &lt;/summary&gt;</span>
 175:        : <span class="white">        /// &lt;typeparam name="T"&gt;</span>
 176:        : <span class="white">        /// A type that implements &lt;see cref="ITestRunner" /&gt;.</span>
 177:        : <span class="white">        /// &lt;/typeparam&gt;</span>
 178:        : <span class="white">        public static void UseRunner&lt;T&gt;() where T : ITestRunner</span>
 179:        : <span class="white">        {</span>
 180:        : <span class="white">            TestRunner = typeof(T);</span>
 181:        : <span class="white">        }</span>
 182:        : <span class="white">    }</span>
 183:        : <span class="white">}</span>
 184:        : <span class="white"></span>
</pre><h1>Module.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System.Collections.Generic;</span>
  23:        : <span class="white">using System.IO;</span>
  24:        : <span class="white">using System.Linq;</span>
  25:        : <span class="white"></span>
  26:        : <span class="white">using Mono.Cecil;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;</span>
  28:        : <span class="white">using Mono.Cecil.Mdb;</span>
  29:        : <span class="white">using Mono.Cecil.Pdb;</span>
  30:        : <span class="white"></span>
  31:        : <span class="white">namespace NinjaTurtles</span>
  32:        : <span class="white">{</span>
  33:        : <span class="white">    /// &lt;summary&gt;</span>
  34:        : <span class="white">    /// Class representing the main module of a .NET assembly.</span>
  35:        : <span class="white">    /// &lt;/summary&gt;</span>
  36:        : <span class="white">    public class Module</span>
  37:        : <span class="white">    {</span>
  38:        : <span class="white">        /// &lt;summary&gt;</span>
  39:        : <span class="white">        /// Initializes a new instance of the &lt;see cref="Module" /&gt; class.</span>
  40:        : <span class="white">        /// &lt;/summary&gt;</span>
  41:        : <span class="white">        /// &lt;param name="assemblyLocation"&gt;</span>
  42:        : <span class="white">        /// The location on disk of the assembly whose main module is to be</span>
  43:        : <span class="white">        /// loaded.</span>
  44:        : <span class="white">        /// &lt;/param&gt;</span>
  45:        : <span class="white">        public Module(string assemblyLocation)</span>
  46:        : <span class="white">        {</span>
  47:        : <span class="white">            AssemblyLocation = assemblyLocation;</span>
  48:        : <span class="white">            AssemblyDefinition = AssemblyDefinition.ReadAssembly(assemblyLocation);</span>
  49:        : <span class="white">            Definition = AssemblyDefinition.MainModule;</span>
  50:        : <span class="white">            SourceFiles = new Dictionary&lt;string, string[]&gt;();</span>
  51:        : <span class="white">        }</span>
  52:        : <span class="white"></span>
  53:        : <span class="white">        /// &lt;summary&gt;</span>
  54:        : <span class="white">        /// Gets the location on disk of the assembly.</span>
  55:        : <span class="white">        /// &lt;/summary&gt;</span>
  56:        : <span class="white">        public string AssemblyLocation { get; private set; }</span>
  57:        : <span class="white"></span>
  58:        : <span class="white">        /// &lt;summary&gt;</span>
  59:        : <span class="white">        /// Gets the &lt;see cref="AssemblyDefinition" /&gt;.</span>
  60:        : <span class="white">        /// &lt;/summary&gt;</span>
  61:        : <span class="white">        public AssemblyDefinition AssemblyDefinition { get; private set; }</span>
  62:        : <span class="white"></span>
  63:        : <span class="white">        /// &lt;summary&gt;</span>
  64:        : <span class="white">        /// Gets the &lt;see cref="ModuleDefinition" /&gt;.</span>
  65:        : <span class="white">        /// &lt;/summary&gt;</span>
  66:        : <span class="white">        public ModuleDefinition Definition { get; private set; }</span>
  67:        : <span class="white"></span>
  68:        : <span class="white">        /// &lt;summary&gt;</span>
  69:        : <span class="white">        /// Gets a dictionary of source code files with their contained lines</span>
  70:        : <span class="white">        /// of code.</span>
  71:        : <span class="white">        /// &lt;/summary&gt;</span>
  72:        : <span class="white">        public IDictionary&lt;string, string[]&gt; SourceFiles { get; private set; } </span>
  73:        : <span class="white"></span>
  74:        : <span class="white">        internal void LoadDebugInformation()</span>
  75:        : <span class="amber">        {</span>
  76:     1/1: <span class="green">            var reader = ResolveSymbolReader();</span>
  77:     7/7: <span class="green">            if (reader == null) return;</span>
  78:        : <span class="white"></span>
  79:     1/1: <span class="green">            Definition.ReadSymbols(reader);</span>
  80:        : <span class="white"></span>
  81:   19/19: <span class="green">            foreach (var method in Definition.Types</span>
  82:     9/9: <span class="green">                .SelectMany(t =&gt; t.Methods)</span>
  83:     9/9: <span class="green">                .Where(m =&gt; m.HasBody))</span>
  84:        : <span class="amber">            {</span>
  85:     1/1: <span class="green">                MethodDefinition capturedMethod = method;</span>
  86:     1/1: <span class="green">                reader.Read(capturedMethod.Body,</span>
  87:     1/1: <span class="green">                    o =&gt; capturedMethod.Body.Instructions.FirstOrDefault(i =&gt; i.Offset &gt;= o));</span>
  88:        : <span class="white"></span>
  89:     7/7: <span class="green">                var sourceFiles = method.Body.Instructions.Where(i =&gt; i.SequencePoint != null)</span>
  90:     7/7: <span class="green">                    .Select(i =&gt; i.SequencePoint.Document.Url)</span>
  91:     7/7: <span class="green">                    .Distinct();</span>
  92:   12/12: <span class="green">                foreach (var sourceFile in sourceFiles)</span>
  93:        : <span class="amber">                {</span>
  94:     9/9: <span class="green">                    if (!SourceFiles.ContainsKey(sourceFile) &amp;&amp; File.Exists(sourceFile))</span>
  95:        : <span class="amber">                    {</span>
  96:     1/1: <span class="green">                        SourceFiles.Add(sourceFile, File.ReadAllLines(sourceFile));</span>
  97:        : <span class="amber">                    }</span>
  98:        : <span class="amber">                }</span>
  99:        : <span class="amber">            }</span>
 100:        : <span class="amber">        }</span>
 101:        : <span class="white"></span>
 102:        : <span class="white">        private ISymbolReader ResolveSymbolReader()</span>
 103:        : <span class="white">        {</span>
 104:        : <span class="white">            string symbolLocation = null;</span>
 105:        : <span class="white">            string pdbLocation = Path.ChangeExtension(AssemblyLocation, "pdb");</span>
 106:        : <span class="white">            string mdbLocation = AssemblyLocation + ".mdb";</span>
 107:        : <span class="white">            ISymbolReaderProvider provider = null;</span>
 108:        : <span class="white">            if (File.Exists(pdbLocation))</span>
 109:        : <span class="white">            {</span>
 110:        : <span class="white">                symbolLocation = pdbLocation;</span>
 111:        : <span class="white">                provider = new PdbReaderProvider();</span>
 112:        : <span class="white">            }</span>
 113:        : <span class="white">            else if (File.Exists(mdbLocation))</span>
 114:        : <span class="white">            {</span>
 115:        : <span class="white">                symbolLocation = AssemblyLocation;</span>
 116:        : <span class="white">                provider = new MdbReaderProvider();</span>
 117:        : <span class="white">            }</span>
 118:        : <span class="white">            if (provider == null) return null;</span>
 119:        : <span class="white">            var reader = provider.GetSymbolReader(Definition, symbolLocation);</span>
 120:        : <span class="white">            return reader;</span>
 121:        : <span class="white">        }</span>
 122:        : <span class="white">    }</span>
 123:        : <span class="white">}</span>
</pre><h1>MethodTestedAttribute.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Reflection;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">namespace NinjaTurtles</span>
  26:        : <span class="white">{</span>
  27:        : <span class="white">    /// &lt;summary&gt;</span>
  28:        : <span class="white">    /// When applied to a unit test method, specifies a member of a class that</span>
  29:        : <span class="white">    /// is tested by that method. This can be applied multiple times for a test</span>
  30:        : <span class="white">    /// that exercises multiple methods.</span>
  31:        : <span class="white">    /// &lt;/summary&gt;</span>
  32:        : <span class="white">    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]</span>
  33:        : <span class="white">    public class MethodTestedAttribute : Attribute</span>
  34:        : <span class="white">    {</span>
  35:        : <span class="white">        /// &lt;summary&gt;</span>
  36:        : <span class="white">        /// Initializes a new instance of the</span>
  37:        : <span class="white">        /// &lt;see cref="MethodTestedAttribute" /&gt; class.</span>
  38:        : <span class="white">        /// &lt;/summary&gt;</span>
  39:        : <span class="white">        /// &lt;param name="targetType"&gt;</span>
  40:        : <span class="white">        /// The type for which the attributed class contains unit tests.</span>
  41:        : <span class="white">        /// &lt;/param&gt;</span>
  42:        : <span class="white">        /// &lt;param name="targetMethod"&gt;</span>
  43:        : <span class="white">        /// The name of a method which is tested by the attributed unit test.</span>
  44:        : <span class="white">        /// &lt;/param&gt;</span>
  45:        : <span class="amber">        public MethodTestedAttribute(Type targetType, string targetMethod)</span>
  46:        : <span class="amber">        {</span>
  47:     1/1: <span class="green">            TargetType = targetType;</span>
  48:     1/1: <span class="green">            TargetMethod = targetMethod;</span>
  49:        : <span class="amber">        }</span>
  50:        : <span class="white"></span>
  51:        : <span class="white">        /// &lt;summary&gt;</span>
  52:        : <span class="white">        /// Initializes a new instance of the</span>
  53:        : <span class="white">        /// &lt;see cref="MethodTestedAttribute" /&gt; class. This overload is</span>
  54:        : <span class="white">        /// designed to allow non-public class's methods to be tested.</span>
  55:        : <span class="white">        /// &lt;/summary&gt;</span>
  56:        : <span class="white">        /// &lt;param name="targetType"&gt;</span>
  57:        : <span class="white">        /// The namespace-qualified name of the type for which the attributed</span>
  58:        : <span class="white">        /// class contains unit tests.</span>
  59:        : <span class="white">        /// &lt;/param&gt;</span>
  60:        : <span class="white">        /// &lt;param name="targetMethod"&gt;</span>
  61:        : <span class="white">        /// The name of a method which is tested by the attributed unit test.</span>
  62:        : <span class="white">        /// &lt;/param&gt;</span>
  63:        : <span class="amber">        public MethodTestedAttribute(string targetType, string targetMethod)</span>
  64:        : <span class="amber">        {</span>
  65:     2/2: <span class="green">            Type resolvedType = TypeResolver.ResolveTypeFromReferences(Assembly.GetCallingAssembly(), targetType);</span>
  66:     1/1: <span class="green">            TargetType = resolvedType;</span>
  67:     2/2: <span class="green">            TargetMethod = targetMethod;</span>
  68:        : <span class="amber">        }</span>
  69:        : <span class="white"></span>
  70:        : <span class="white">        internal Type TargetType { get; private set; }</span>
  71:        : <span class="white"></span>
  72:        : <span class="white">        internal string TargetMethod { get; private set; }</span>
  73:        : <span class="white"></span>
  74:        : <span class="white">        /// &lt;summary&gt;</span>
  75:        : <span class="white">        /// Gets or sets a list of parameter types used to identify a</span>
  76:        : <span class="white">        /// particular method overload.</span>
  77:        : <span class="white">        /// &lt;/summary&gt;</span>
  78:        : <span class="white">        public Type[] ParameterTypes { get; set; }</span>
  79:        : <span class="white">    }</span>
  80:        : <span class="white">}</span>
  81:        : <span class="white"></span>
</pre><h1>MethodDefinitionResolver.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Linq;</span>
  24:        : <span class="white"></span>
  25:        : <span class="white">using Mono.Cecil;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">using NLog;</span>
  28:        : <span class="white"></span>
  29:        : <span class="white">namespace NinjaTurtles</span>
  30:        : <span class="white">{</span>
  31:        : <span class="white">    internal class MethodDefinitionResolver</span>
  32:        : <span class="white">    {</span>
  33:        : <span class="white">        #region Logging</span>
  34:        : <span class="white"></span>
  35:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();</span>
  36:        : <span class="white"></span>
  37:        : <span class="white">        #endregion</span>
  38:        : <span class="white"></span>
  39:        : <span class="white">        public static MethodDefinition ResolveMethod(TypeDefinition typeDefinition, string methodName)</span>
  40:        : <span class="amber">        {</span>
  41:     1/1: <span class="green">            _log.Debug("Resolving method \"{0}\" in \"{1}\".", methodName, typeDefinition.FullName);</span>
  42:        : <span class="white">            try</span>
  43:        : <span class="amber">            {</span>
  44:     5/5: <span class="green">                MethodDefinition methodDefinition = typeDefinition.Methods.Single(m =&gt; m.Name == methodName);</span>
  45:     1/1: <span class="green">                _log.Debug("Method \"{0}\" successfully resolved in \"{1}\".", methodName, typeDefinition.FullName);</span>
  46:     3/3: <span class="green">                return methodDefinition;</span>
  47:        : <span class="white">            }</span>
  48:     1/1: <span class="green">            catch (InvalidOperationException ex)</span>
  49:        : <span class="amber">            {</span>
  50:     5/5: <span class="green">                if (ex.Message == "Sequence contains no matching element")</span>
  51:        : <span class="amber">                {</span>
  52:     1/1: <span class="green">                    _log.Error("Method \"{0}\" is unrecognised.", methodName);</span>
  53:     1/1: <span class="green">                    throw new ArgumentException(string.Format("Method \"{0}\" is unrecognised.", methodName), "methodName");</span>
  54:        : <span class="white">                }</span>
  55:     1/1: <span class="green">                _log.Error("Method \"{0}\" is overloaded.", methodName);</span>
  56:     1/1: <span class="green">                throw new ArgumentException(string.Format("Method \"{0}\" is overloaded.", methodName), "methodName");</span>
  57:        : <span class="white">            }</span>
  58:        : <span class="amber">        }</span>
  59:        : <span class="white"></span>
  60:        : <span class="white">        public static MethodDefinition ResolveMethod(TypeDefinition typeDefinition, string methodName, Type[] parameterTypes)</span>
  61:        : <span class="amber">        {</span>
  62:     5/5: <span class="green">            if (parameterTypes == null)</span>
  63:        : <span class="amber">            {</span>
  64:     1/1: <span class="green">                _log.Warn("\"ResolveMethod\" overload with parameter types called unnecessarily.");</span>
  65:     3/3: <span class="green">                return ResolveMethod(typeDefinition, methodName);</span>
  66:        : <span class="white">            }</span>
  67:        : <span class="white">            try</span>
  68:        : <span class="amber">            {</span>
  69:     5/5: <span class="green">                MethodDefinition methodDefinition =</span>
  70:     5/5: <span class="green">                    typeDefinition.Methods.Single(</span>
  71:     5/5: <span class="green">                        m =&gt; m.Name == methodName</span>
  72:     5/5: <span class="green">                            &amp;&amp; Enumerable.SequenceEqual(</span>
  73:     5/5: <span class="green">                                m.Parameters.Select(p =&gt; p.ParameterType.Name.Replace("TypeDefinition", "Type")),</span>
  74:     5/5: <span class="green">                                parameterTypes.Select(p =&gt; p.Name)));</span>
  75:     1/1: <span class="green">                _log.Debug("Method \"{0}\" successfully resolved in \"{1}\".", methodName, typeDefinition.FullName);</span>
  76:     3/3: <span class="green">                return methodDefinition;</span>
  77:        : <span class="white">            }</span>
  78:        : <span class="amber">            catch (InvalidOperationException)</span>
  79:        : <span class="amber">            {</span>
  80:     1/1: <span class="green">                _log.Error("Method \"{0}\" with specified parameter types is unrecognised.", methodName);</span>
  81:     1/1: <span class="green">                throw new ArgumentException(string.Format("Method \"{0}\" with specified parameter types is unrecognised.", methodName), "methodName");</span>
  82:        : <span class="white">            }</span>
  83:        : <span class="amber">        }</span>
  84:        : <span class="white">    }</span>
  85:        : <span class="white">}</span>
</pre><h1>ConsoleProcessFactory.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence</span>
   2:        : <span class="white"></span>
   3:        : <span class="white">// This file is part of NinjaTurtles.</span>
   4:        : <span class="white">// </span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the</span>
   8:        : <span class="white">// License, or (at your option) any later version.</span>
   9:        : <span class="white">// </span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.</span>
  14:        : <span class="white">// </span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  17:        : <span class="white">// </span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.</span>
  19:        : <span class="white"></span>
  20:        : <span class="white">#endregion</span>
  21:        : <span class="white"></span>
  22:        : <span class="white">using System;</span>
  23:        : <span class="white">using System.Collections.Generic;</span>
  24:        : <span class="white">using System.Diagnostics;</span>
  25:        : <span class="white">using System.IO;</span>
  26:        : <span class="white"></span>
  27:        : <span class="white">namespace NinjaTurtles</span>
  28:        : <span class="white">{</span>
  29:        : <span class="white">    /// &lt;summary&gt;</span>
  30:        : <span class="white">    /// A factory class used to instatiate a &lt;see cref="Process" /&gt; instance,</span>
  31:        : <span class="white">    /// taking into account the operating system and runtime.</span>
  32:        : <span class="white">    /// &lt;/summary&gt;</span>
  33:        : <span class="white">    public static class ConsoleProcessFactory</span>
  34:        : <span class="white">    {</span>
  35:        : <span class="white">        internal static bool IsMono { get; set; }</span>
  36:        : <span class="white">        internal static bool IsWindows { get; set; }</span>
  37:        : <span class="white"></span>
  38:        : <span class="white">        static ConsoleProcessFactory()</span>
  39:        : <span class="white">        {</span>
  40:        : <span class="white">            IsMono = Type.GetType("Mono.Runtime") != null;</span>
  41:        : <span class="white">            IsWindows = Environment.OSVersion.Platform.ToString().StartsWith("Win")</span>
  42:        : <span class="white">                        || Environment.OSVersion.Platform == PlatformID.Xbox;</span>
  43:        : <span class="white">        }</span>
  44:        : <span class="white"></span>
  45:        : <span class="white">        /// &lt;summary&gt;</span>
  46:        : <span class="white">        /// Creates a &lt;see cref="Process" /&gt; instance used to execute the</span>
  47:        : <span class="white">        /// executable identifier by the &lt;paramref name="exeName"/&gt;</span>
  48:        : <span class="white">        /// parameter, with the &lt;paramref name="arguments"/&gt; specified.</span>
  49:        : <span class="white">        /// &lt;/summary&gt;</span>
  50:        : <span class="white">        /// &lt;param name="exeName"&gt;</span>
  51:        : <span class="white">        /// The name (and path) of the executable to run.</span>
  52:        : <span class="white">        /// &lt;/param&gt;</span>
  53:        : <span class="white">        /// &lt;param name="arguments"&gt;</span>
  54:        : <span class="white">        /// The command line arguments to pass to the executable.</span>
  55:        : <span class="white">        /// &lt;/param&gt;</span>
  56:        : <span class="white">        /// &lt;param name="additionalSearchLocations"&gt;</span>
  57:        : <span class="white">        /// An optional list of additional search paths.</span>
  58:        : <span class="white">        /// &lt;/param&gt;</span>
  59:        : <span class="white">        /// &lt;returns&gt;</span>
  60:        : <span class="white">        /// An instance of &lt;see cref="Process" /&gt;.</span>
  61:        : <span class="white">        /// &lt;/returns&gt;</span>
  62:        : <span class="white">        public static Process CreateProcess(string exeName, string arguments, params string[] additionalSearchLocations)</span>
  63:        : <span class="amber">        {</span>
  64:     2/2: <span class="green">            exeName = FindExecutable(exeName, additionalSearchLocations);</span>
  65:        : <span class="white"></span>
  66:     5/5: <span class="green">            if (IsMono)</span>
  67:        : <span class="amber">            {</span>
  68:     3/3: <span class="green">                arguments = string.Format("--runtime=v4.0 \"{0}\" {1}", exeName, arguments);</span>
  69:     1/1: <span class="green">                exeName = "mono";</span>
  70:        : <span class="amber">            }</span>
  71:        : <span class="white"></span>
  72:     6/6: <span class="green">            arguments = string.Format(arguments, IsWindows ? "/" : "-");</span>
  73:        : <span class="white"></span>
  74:     3/3: <span class="green">            var processStartInfo = new ProcessStartInfo(exeName, arguments);</span>
  75:     1/1: <span class="green">            processStartInfo.UseShellExecute = false;</span>
  76:     1/1: <span class="green">            processStartInfo.CreateNoWindow = true;</span>
  77:     1/1: <span class="green">            processStartInfo.RedirectStandardOutput = true;</span>
  78:        : <span class="white"></span>
  79:     4/4: <span class="green">            return new Process</span>
  80:     4/4: <span class="green">            {</span>
  81:     4/4: <span class="green">                StartInfo = processStartInfo</span>
  82:     4/4: <span class="green">            };</span>
  83:        : <span class="amber">        }</span>
  84:        : <span class="white"></span>
  85:        : <span class="white">        private static string FindExecutable(string exeName, string[] additionalSearchLocations)</span>
  86:        : <span class="amber">        {</span>
  87:     1/1: <span class="green">            var searchPath = new List&lt;string&gt;();</span>
  88:     1/1: <span class="green">            searchPath.AddRange(additionalSearchLocations);</span>
  89:     7/7: <span class="green">            string environmentSearchPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;</span>
  90:     9/9: <span class="green">            searchPath.AddRange(environmentSearchPath.Split(IsWindows ? ';' : ':'));</span>
  91:        : <span class="white"></span>
  92:   12/12: <span class="green">            foreach (string folder in searchPath)</span>
  93:        : <span class="amber">            {</span>
  94:   12/12: <span class="green">                string fullExePath = Path.Combine(folder, exeName);</span>
  95:     9/9: <span class="green">                if (File.Exists(fullExePath))</span>
  96:        : <span class="amber">                {</span>
  97:     8/8: <span class="green">                    return fullExePath;</span>
  98:        : <span class="white">                }</span>
  99:        : <span class="amber">            }</span>
 100:     8/8: <span class="green">            return exeName;</span>
 101:        : <span class="amber">        }</span>
 102:        : <span class="white">    }</span>
 103:        : <span class="white">}</span>
</pre></body></html>