<html xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:ninj="http://ninjaturtles.codeplex.com/functions" xmlns="http://www.w3.org/1999/xhtml"><head><style type="text/css">
                    body {
                        font-family: Trebuchet MS,Verdana,Arial;
                        font-size: 0.8em;
                    }
                    table {
                    	font-size: 1em;
                    	border-spacing: 0;
                    }
                    table td {
                    	padding: 0;
                    	border-left: solid 1px #888;
                    	border-right: solid 1px #888;
                    	border-bottom: solid 1px #888;
                    }
                    table th {
                    	padding: 2px;
                    }
                    table tr {
                    	 height: 20px;
                    }
                    th.file {
                    	width: 400px;
                    }
                    th.mutants, th.sequence_points {
                    	width: 118px;
                    }
                    h1 {
                        font-size: 1.5em;
                    }
                    pre {
                        font-family: Consolas, Lucida Console, Courier New, Courier;
                    }
                    .red {
                        background-color: #fcc;
                    }
                    .amber {
                        background-color: #fff8e8;
                    }
                    .green {
                        background-color: #cfc;
                    }
                    .title, th {
                        background-color: #000;
                        color: #fff;
                        font-weight: bold;
                        text-align: left;
                    }
                    .bar-wrap {
                    	position: relative;
                    }
                    .bar-wrap, .bar-value, .bar-text {
                    	width: 120px;
                    	height: 20px;
                    }
                    .bar-wrap, .bar-value {
                    	background-color: #fdd;
                    }
                    .bar-text {
                    	position: absolute;
                    	top: 0; left: 0;
                    	padding-top: 2px;
                    	color: #000;
                    	text-align: center;
                    	width: 100%;
                    }
                </style></head><body><table><thead><tr><th class="file">File</th><th class="mutants">Mutants</th><th class="sequence_points">Sequence points</th></tr></thead><tbody><tr><td>ArithmeticOperatorTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td></tr><tr><td>BitwiseOperatorTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td></tr><tr><td>BranchConditionTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">1 /
    			1</div></div></div></td></tr><tr><td>ConditionalBoundaryTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">90 /
    			90</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">16 /
    			16</div></div></div></td></tr><tr><td>ConsoleProcessFactory.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">93 /
    			93</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 87.5%"><div class="bar-text">21 /
    			24</div></div></div></td></tr><tr><td>InstructionExtensions.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">85 /
    			85</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 82.352941176470588235%"><div class="bar-text">14 /
    			17</div></div></div></td></tr><tr><td>MethodDefinitionResolver.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">41 /
    			41</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 81.818181818181818182%"><div class="bar-text">18 /
    			22</div></div></div></td></tr><tr><td>MethodTurtleBase.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">10 /
    			10</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 80%"><div class="bar-text">4 /
    			5</div></div></div></td></tr><tr><td>Module.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">58 /
    			58</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 94.117647058823529412%"><div class="bar-text">16 /
    			17</div></div></div></td></tr><tr><td>MutationTest.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">417 /
    			417</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 94.262295081967213115%"><div class="bar-text">115 /
    			122</div></div></div></td></tr><tr><td>MutationTestBuilder.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">4 /
    			4</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 75%"><div class="bar-text">3 /
    			4</div></div></div></td></tr><tr><td>OpCodeRotationTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">64 /
    			64</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">16 /
    			16</div></div></div></td></tr><tr><td>SequencePointDeletionTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">234 /
    			234</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 97.777777777777777778%"><div class="bar-text">44 /
    			45</div></div></div></td></tr><tr><td>TestDirectory.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">196 /
    			196</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 97.222222222222222222%"><div class="bar-text">35 /
    			36</div></div></div></td></tr><tr><td>TypeResolver.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">66 /
    			66</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 88%"><div class="bar-text">22 /
    			25</div></div></div></td></tr><tr><td>VariableReadTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">223 /
    			223</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">47 /
    			47</div></div></div></td></tr><tr><td>VariableWriteTurtle.cs</td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">182 /
    			182</div></div></div></td><td><div class="bar-wrap"><div class="bar-value" style="background: #dfd; width: 100%"><div class="bar-text">39 /
    			39</div></div></div></td></tr></tbody></table><h1>ArithmeticOperatorTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">&#x200b;</span>
  24:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  27:        : <span class="white">{&#x200b;</span>
  28:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  29:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle"/&gt; that replaces each of&#x200b;</span>
  30:        : <span class="white">    /// the arithmetic operators &lt;see cref="OpCodes.Add" /&gt;,&#x200b;</span>
  31:        : <span class="white">    /// &lt;see cref="OpCodes.Sub" /&gt;, &lt;see cref="OpCodes.Mul" /&gt;,&#x200b;</span>
  32:        : <span class="white">    /// &lt;see cref="OpCodes.Div" /&gt; and &lt;see cref="OpCodes.Rem" /&gt; with each&#x200b;</span>
  33:        : <span class="white">    /// of the others in turn.&#x200b;</span>
  34:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  35:        : <span class="white">    public class ArithmeticOperatorTurtle : OpCodeRotationTurtle&#x200b;</span>
  36:        : <span class="white">    {&#x200b;</span>
  37:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  38:        : <span class="white">        /// Initializes a new instance of &#x200b;</span>
  39:        : <span class="white">        /// &lt;see cref="ArithmeticOperatorTurtle" /&gt;.&#x200b;</span>
  40:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  41:        : <span class="white">        public ArithmeticOperatorTurtle()&#x200b;</span>
  42:        : <span class="white">        {&#x200b;</span>
  43:     1/1: <span class="green">            _opCodes = new Dictionary&lt;OpCode, IEnumerable&lt;OpCode&gt;&gt;&#x200b;</span>
  44:     1/1: <span class="green">                           {&#x200b;</span>
  45:     1/1: <span class="green">                               {OpCodes.Add, new[] {OpCodes.Sub, OpCodes.Mul, OpCodes.Div, OpCodes.Rem}},&#x200b;</span>
  46:     1/1: <span class="green">                               {OpCodes.Sub, new[] {OpCodes.Add, OpCodes.Mul, OpCodes.Div, OpCodes.Rem}},&#x200b;</span>
  47:     1/1: <span class="green">                               {OpCodes.Mul, new[] {OpCodes.Add, OpCodes.Sub, OpCodes.Div, OpCodes.Rem}},&#x200b;</span>
  48:     1/1: <span class="green">                               {OpCodes.Div, new[] {OpCodes.Add, OpCodes.Sub, OpCodes.Mul, OpCodes.Rem}},&#x200b;</span>
  49:     1/1: <span class="green">                               {OpCodes.Rem, new[] {OpCodes.Add, OpCodes.Sub, OpCodes.Mul, OpCodes.Div}}&#x200b;</span>
  50:     1/1: <span class="green">                           };&#x200b;</span>
  51:        : <span class="white">        }&#x200b;</span>
  52:        : <span class="white">    }&#x200b;</span>
  53:        : <span class="white">}&#x200b;</span>
  54:        : <span class="white">&#x200b;</span>
</pre><h1>BitwiseOperatorTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">&#x200b;</span>
  24:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  27:        : <span class="white">{&#x200b;</span>
  28:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  29:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle"/&gt; that replaces each of&#x200b;</span>
  30:        : <span class="white">    /// the bitwise operators &lt;see cref="OpCodes.Or" /&gt;,&#x200b;</span>
  31:        : <span class="white">    /// &lt;see cref="OpCodes.And" /&gt; and &lt;see cref="OpCodes.Xor" /&gt; with each&#x200b;</span>
  32:        : <span class="white">    /// of the others in turn.&#x200b;</span>
  33:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  34:        : <span class="white">    public class BitwiseOperatorTurtle : OpCodeRotationTurtle&#x200b;</span>
  35:        : <span class="white">    {&#x200b;</span>
  36:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  37:        : <span class="white">        /// Initializes a new instance of &lt;see cref="BitwiseOperatorTurtle" /&gt;.&#x200b;</span>
  38:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  39:        : <span class="white">        public BitwiseOperatorTurtle()&#x200b;</span>
  40:        : <span class="white">        {&#x200b;</span>
  41:     1/1: <span class="green">            _opCodes = new Dictionary&lt;OpCode, IEnumerable&lt;OpCode&gt;&gt;&#x200b;</span>
  42:     1/1: <span class="green">                           {&#x200b;</span>
  43:     1/1: <span class="green">                               {OpCodes.Or, new[] {OpCodes.And, OpCodes.Xor}},&#x200b;</span>
  44:     1/1: <span class="green">                               {OpCodes.And, new[] {OpCodes.Or, OpCodes.Xor}},&#x200b;</span>
  45:     1/1: <span class="green">                               {OpCodes.Xor, new[] {OpCodes.Or, OpCodes.And}}&#x200b;</span>
  46:     1/1: <span class="green">                           };&#x200b;</span>
  47:        : <span class="white">        }&#x200b;</span>
  48:        : <span class="white">    }&#x200b;</span>
  49:        : <span class="white">}&#x200b;</span>
</pre><h1>BranchConditionTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">&#x200b;</span>
  24:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  27:        : <span class="white">{&#x200b;</span>
  28:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  29:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle"/&gt; that replaces the&#x200b;</span>
  30:        : <span class="white">    /// conditional branch operators&#x200b;</span>
  31:        : <span class="white">    /// &lt;see cref="OpCodes.Brtrue" /&gt; and &lt;see cref="OpCodes.Brfalse"/&gt; with&#x200b;</span>
  32:        : <span class="white">    /// their converse and with the operators &lt;see cref="OpCodes.Br"/&gt; (always&#x200b;</span>
  33:        : <span class="white">    /// branch) and &lt;see cref="OpCodes.Nop" /&gt; (never branch) in turn.&#x200b;</span>
  34:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  35:        : <span class="white">    public class BranchConditionTurtle : OpCodeRotationTurtle&#x200b;</span>
  36:        : <span class="white">    {&#x200b;</span>
  37:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  38:        : <span class="white">        /// Initializes a new instance of &lt;see cref="BranchConditionTurtle" /&gt;.&#x200b;</span>
  39:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  40:        : <span class="white">        public BranchConditionTurtle()&#x200b;</span>
  41:        : <span class="white">        {&#x200b;</span>
  42:     1/1: <span class="green">            _opCodes = new Dictionary&lt;OpCode, IEnumerable&lt;OpCode&gt;&gt;&#x200b;</span>
  43:     1/1: <span class="green">                           {&#x200b;</span>
  44:     1/1: <span class="green">                               {OpCodes.Brtrue, new[] {OpCodes.Nop, OpCodes.Brfalse, OpCodes.Br}},&#x200b;</span>
  45:     1/1: <span class="green">                               {OpCodes.Brfalse, new[] {OpCodes.Nop, OpCodes.Brtrue, OpCodes.Br}}&#x200b;</span>
  46:     1/1: <span class="green">                           };&#x200b;</span>
  47:        : <span class="white">        }&#x200b;</span>
  48:        : <span class="white">    }&#x200b;</span>
  49:        : <span class="white">}&#x200b;</span>
</pre><h1>ConditionalBoundaryTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">&#x200b;</span>
  24:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  25:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  28:        : <span class="white">{&#x200b;</span>
  29:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  30:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle"/&gt; that changes&#x200b;</span>
  31:        : <span class="white">    /// whether or not equality is included in comparison operators, so&#x200b;</span>
  32:        : <span class="white">    /// for example &lt;see cref="OpCodes.Clt" /&gt; is replaced by a combination&#x200b;</span>
  33:        : <span class="white">    /// of &lt;see cref="OpCodes.Cgt" /&gt; and a comparison with zero to give the&#x200b;</span>
  34:        : <span class="white">    /// effect of a &amp;lt;= operator.&#x200b;</span>
  35:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  36:        : <span class="white">    public class ConditionalBoundaryTurtle : MethodTurtleBase&#x200b;</span>
  37:        : <span class="white">    {&#x200b;</span>
  38:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  39:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
  40:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
  41:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  42:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
  43:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
  44:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
  45:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
  46:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  47:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  48:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  49:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  50:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  51:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  52:        : <span class="white">        /// containing assembly.&#x200b;</span>
  53:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  54:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  55:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  56:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  57:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  58:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)&#x200b;</span>
  59:        : <span class="white">        {&#x200b;</span>
  60:   16/16: <span class="green">            for (int index = 0; index &lt; method.Body.Instructions.Count; index++)&#x200b;</span>
  61:        : <span class="white">            {&#x200b;</span>
  62:     4/4: <span class="green">                var instruction = method.Body.Instructions[index];&#x200b;</span>
  63:   13/13: <span class="green">                if (instruction.OpCode == OpCodes.Clt&#x200b;</span>
  64:   13/13: <span class="green">                    || instruction.OpCode == OpCodes.Cgt)&#x200b;</span>
  65:        : <span class="white">                {&#x200b;</span>
  66:     3/3: <span class="green">                    var originalCode = instruction.OpCode.Code;&#x200b;</span>
  67:        : <span class="white">&#x200b;</span>
  68:     3/3: <span class="green">                    var loadZero = method.Body.GetILProcessor().Create(OpCodes.Ldc_I4_0);&#x200b;</span>
  69:     3/3: <span class="green">                    var compareEqual = method.Body.GetILProcessor().Create(OpCodes.Ceq);&#x200b;</span>
  70:        : <span class="white">&#x200b;</span>
  71:     8/8: <span class="green">                    method.Body.Instructions.Insert(index + 1, compareEqual);&#x200b;</span>
  72:     8/8: <span class="green">                    method.Body.Instructions.Insert(index + 1, loadZero);&#x200b;</span>
  73:        : <span class="white">&#x200b;</span>
  74:     8/8: <span class="green">                    instruction.OpCode = instruction.OpCode == OpCodes.Clt ? OpCodes.Cgt : OpCodes.Clt;&#x200b;</span>
  75:        : <span class="white">&#x200b;</span>
  76:     4/4: <span class="green">                    var description = string.Format("{0:x4}: {1} =&gt; not {2}", GetOriginalOffset(index), originalCode, instruction.OpCode.Code);&#x200b;</span>
  77:     4/4: <span class="green">                    yield return DoYield(method, module, description, index);&#x200b;</span>
  78:        : <span class="white">&#x200b;</span>
  79:     8/8: <span class="green">                    instruction.OpCode = instruction.OpCode == OpCodes.Clt ? OpCodes.Cgt : OpCodes.Clt;&#x200b;</span>
  80:        : <span class="white">&#x200b;</span>
  81:     3/3: <span class="green">                    method.Body.Instructions.Remove(compareEqual);&#x200b;</span>
  82:     3/3: <span class="green">                    method.Body.Instructions.Remove(loadZero);&#x200b;</span>
  83:        : <span class="white">                }&#x200b;</span>
  84:        : <span class="white">            }&#x200b;</span>
  85:        : <span class="white">        }&#x200b;</span>
  86:        : <span class="white">    }&#x200b;</span>
  87:        : <span class="white">}&#x200b;</span>
</pre><h1>ConsoleProcessFactory.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Diagnostics;&#x200b;</span>
  25:        : <span class="white">using System.IO;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  28:        : <span class="white">{&#x200b;</span>
  29:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  30:        : <span class="white">    /// A factory class used to instatiate a &lt;see cref="Process" /&gt; instance,&#x200b;</span>
  31:        : <span class="white">    /// taking into account the operating system and runtime.&#x200b;</span>
  32:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  33:        : <span class="white">    public static class ConsoleProcessFactory&#x200b;</span>
  34:        : <span class="white">    {&#x200b;</span>
  35:        : <span class="white">        internal static bool IsMono { get; set; }&#x200b;</span>
  36:        : <span class="white">        internal static bool IsWindows { get; set; }&#x200b;</span>
  37:        : <span class="white">&#x200b;</span>
  38:        : <span class="white">        static ConsoleProcessFactory()&#x200b;</span>
  39:        : <span class="white">        {&#x200b;</span>
  40:        : <span class="white">            IsMono = Type.GetType("Mono.Runtime") != null;&#x200b;</span>
  41:        : <span class="white">            IsWindows = Environment.OSVersion.Platform.ToString().StartsWith("Win")&#x200b;</span>
  42:        : <span class="white">                        || Environment.OSVersion.Platform == PlatformID.Xbox;&#x200b;</span>
  43:        : <span class="white">        }&#x200b;</span>
  44:        : <span class="white">&#x200b;</span>
  45:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  46:        : <span class="white">        /// Creates a &lt;see cref="Process" /&gt; instance used to execute the&#x200b;</span>
  47:        : <span class="white">        /// executable identifier by the &lt;paramref name="exeName"/&gt;&#x200b;</span>
  48:        : <span class="white">        /// parameter, with the &lt;paramref name="arguments"/&gt; specified.&#x200b;</span>
  49:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  50:        : <span class="white">        /// &lt;param name="exeName"&gt;&#x200b;</span>
  51:        : <span class="white">        /// The name (and path) of the executable to run.&#x200b;</span>
  52:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  53:        : <span class="white">        /// &lt;param name="arguments"&gt;&#x200b;</span>
  54:        : <span class="white">        /// The command line arguments to pass to the executable.&#x200b;</span>
  55:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  56:        : <span class="white">        /// &lt;param name="additionalSearchLocations"&gt;&#x200b;</span>
  57:        : <span class="white">        /// An optional list of additional search paths.&#x200b;</span>
  58:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  59:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  60:        : <span class="white">        /// An instance of &lt;see cref="Process" /&gt;.&#x200b;</span>
  61:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  62:        : <span class="white">        public static Process CreateProcess(string exeName, string arguments, params string[] additionalSearchLocations)&#x200b;</span>
  63:        : <span class="white">        {&#x200b;</span>
  64:     2/2: <span class="green">            exeName = FindExecutable(exeName, additionalSearchLocations);&#x200b;</span>
  65:        : <span class="white">&#x200b;</span>
  66:     5/5: <span class="green">            if (IsMono)&#x200b;</span>
  67:        : <span class="white">            {&#x200b;</span>
  68:     3/3: <span class="green">                arguments = string.Format("--runtime=v4.0 \"{0}\" {1}", exeName, arguments);&#x200b;</span>
  69:     1/1: <span class="green">                exeName = "mono";&#x200b;</span>
  70:        : <span class="white">            }&#x200b;</span>
  71:        : <span class="white">&#x200b;</span>
  72:     5/5: <span class="green">            arguments = string.Format(arguments, IsWindows ? "/" : "-");&#x200b;</span>
  73:        : <span class="white">&#x200b;</span>
  74:     3/3: <span class="green">            var processStartInfo = new ProcessStartInfo(exeName, arguments);&#x200b;</span>
  75:     1/1: <span class="green">            processStartInfo.UseShellExecute = false;&#x200b;</span>
  76:     1/1: <span class="green">            processStartInfo.CreateNoWindow = true;&#x200b;</span>
  77:     1/1: <span class="green">            processStartInfo.RedirectStandardOutput = true;&#x200b;</span>
  78:        : <span class="white">&#x200b;</span>
  79:     4/4: <span class="green">            return new Process&#x200b;</span>
  80:     4/4: <span class="green">            {&#x200b;</span>
  81:     4/4: <span class="green">                StartInfo = processStartInfo&#x200b;</span>
  82:     4/4: <span class="green">            };&#x200b;</span>
  83:        : <span class="amber">        }&#x200b;</span>
  84:        : <span class="white">&#x200b;</span>
  85:        : <span class="white">        private static string FindExecutable(string exeName, string[] additionalSearchLocations)&#x200b;</span>
  86:        : <span class="white">        {&#x200b;</span>
  87:     1/1: <span class="green">            var searchPath = new List&lt;string&gt;();&#x200b;</span>
  88:     1/1: <span class="green">            searchPath.AddRange(additionalSearchLocations);&#x200b;</span>
  89:     7/7: <span class="green">            string environmentSearchPath = Environment.GetEnvironmentVariable("PATH") ?? string.Empty;&#x200b;</span>
  90:     8/8: <span class="green">            searchPath.AddRange(environmentSearchPath.Split(IsWindows ? ';' : ':'));&#x200b;</span>
  91:        : <span class="white">&#x200b;</span>
  92:   12/12: <span class="green">            foreach (string folder in searchPath)&#x200b;</span>
  93:        : <span class="white">            {&#x200b;</span>
  94:   12/12: <span class="green">                string fullExePath = Path.Combine(folder, exeName);&#x200b;</span>
  95:     9/9: <span class="green">                if (File.Exists(fullExePath))&#x200b;</span>
  96:        : <span class="white">                {&#x200b;</span>
  97:     8/8: <span class="green">                    return fullExePath;&#x200b;</span>
  98:        : <span class="white">                }&#x200b;</span>
  99:        : <span class="white">            }&#x200b;</span>
 100:     9/9: <span class="green">            return exeName;&#x200b;</span>
 101:        : <span class="amber">        }&#x200b;</span>
 102:        : <span class="white">    }&#x200b;</span>
 103:        : <span class="white">}&#x200b;</span>
</pre><h1>InstructionExtensions.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Linq;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  28:        : <span class="white">&#x200b;</span>
  29:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  30:        : <span class="white">{&#x200b;</span>
  31:        : <span class="white">    internal static class InstructionExtensions&#x200b;</span>
  32:        : <span class="white">    {&#x200b;</span>
  33:        : <span class="white">        internal static  bool IsMeaninglessUnconditionalBranch(this Instruction instruction)&#x200b;</span>
  34:        : <span class="white">        {&#x200b;</span>
  35:     3/3: <span class="green">            return instruction.OpCode == OpCodes.Br&#x200b;</span>
  36:     3/3: <span class="green">                &amp;&amp; ((Instruction)instruction.Operand).Offset == instruction.Next.Offset;&#x200b;</span>
  37:        : <span class="amber">        }&#x200b;</span>
  38:        : <span class="white">&#x200b;</span>
  39:        : <span class="white">        internal static bool FollowsSequence(this Instruction instruction, params OpCode[] sequence)&#x200b;</span>
  40:        : <span class="white">        {&#x200b;</span>
  41:        : <span class="white">            if (instruction.OpCode != sequence[0]) return false;&#x200b;</span>
  42:        : <span class="white">            if (sequence.Length == 1) return true;&#x200b;</span>
  43:        : <span class="white">            var newSequence = new OpCode[sequence.Length - 1];&#x200b;</span>
  44:        : <span class="white">            Array.Copy(sequence, 1, newSequence, 0, newSequence.Length);&#x200b;</span>
  45:        : <span class="white">            return instruction.Next.FollowsSequence(newSequence);&#x200b;</span>
  46:        : <span class="white">        }&#x200b;</span>
  47:        : <span class="white">&#x200b;</span>
  48:        : <span class="white">        internal static bool IsPartOfSequence(this Instruction instruction, params OpCode[] sequence)&#x200b;</span>
  49:        : <span class="white">        {&#x200b;</span>
  50:        : <span class="white">            if (!sequence.Distinct().Contains(instruction.OpCode)) return false;&#x200b;</span>
  51:        : <span class="white">            var startInstruction = instruction;&#x200b;</span>
  52:        : <span class="white">            for (int i = 0; i &lt; sequence.Length; i++)&#x200b;</span>
  53:        : <span class="white">            {&#x200b;</span>
  54:        : <span class="white">                if (startInstruction == null) break;&#x200b;</span>
  55:        : <span class="white">                if (startInstruction.FollowsSequence(sequence)) return true;&#x200b;</span>
  56:        : <span class="white">                startInstruction = startInstruction.Previous;&#x200b;</span>
  57:        : <span class="white">            }&#x200b;</span>
  58:        : <span class="white">            return false;&#x200b;</span>
  59:        : <span class="white">        }&#x200b;</span>
  60:        : <span class="white">&#x200b;</span>
  61:        : <span class="white">        internal static bool IsPartOfCompilerGeneratedDispose(this Instruction instruction)&#x200b;</span>
  62:        : <span class="white">        {&#x200b;</span>
  63:        : <span class="white">            if (instruction.IsPartOfSequence(OpCodes.Leave,&#x200b;</span>
  64:        : <span class="white">                OpCodes.Ldloc, OpCodes.Ldnull, OpCodes.Ceq,&#x200b;</span>
  65:        : <span class="white">                OpCodes.Stloc, OpCodes.Ldloc, OpCodes.Brtrue,&#x200b;</span>
  66:        : <span class="white">                OpCodes.Ldloc, OpCodes.Callvirt))&#x200b;</span>
  67:        : <span class="white">            {&#x200b;</span>
  68:        : <span class="white">                while (instruction.OpCode != OpCodes.Callvirt)&#x200b;</span>
  69:        : <span class="white">                {&#x200b;</span>
  70:        : <span class="white">                    instruction = instruction.Next;&#x200b;</span>
  71:        : <span class="white">                }&#x200b;</span>
  72:        : <span class="white">                var method = ((MethodReference)instruction.Operand);&#x200b;</span>
  73:        : <span class="white">                return method.Name == "Dispose";&#x200b;</span>
  74:        : <span class="white">            }&#x200b;</span>
  75:        : <span class="white">            if (instruction.IsPartOfSequence(OpCodes.Leave,&#x200b;</span>
  76:        : <span class="white">                OpCodes.Ldloc, OpCodes.Ldnull, OpCodes.Ceq,&#x200b;</span>
  77:        : <span class="white">                OpCodes.Brtrue,&#x200b;</span>
  78:        : <span class="white">                OpCodes.Ldloc, OpCodes.Callvirt))&#x200b;</span>
  79:        : <span class="white">            {&#x200b;</span>
  80:        : <span class="white">                while (instruction.OpCode != OpCodes.Callvirt)&#x200b;</span>
  81:        : <span class="white">                {&#x200b;</span>
  82:        : <span class="white">                    instruction = instruction.Next;&#x200b;</span>
  83:        : <span class="white">                }&#x200b;</span>
  84:        : <span class="white">                var method = ((MethodReference)instruction.Operand);&#x200b;</span>
  85:        : <span class="white">                return method.Name == "Dispose";&#x200b;</span>
  86:        : <span class="white">            }&#x200b;</span>
  87:        : <span class="white">            if (instruction.IsPartOfSequence(OpCodes.Nop, OpCodes.Ldc_I4, OpCodes.Stloc,&#x200b;</span>
  88:        : <span class="white">                OpCodes.Leave, OpCodes.Ldarg, OpCodes.Call,&#x200b;</span>
  89:        : <span class="white">                OpCodes.Nop, OpCodes.Endfinally))&#x200b;</span>
  90:        : <span class="white">            {&#x200b;</span>
  91:        : <span class="white">                if (instruction.OpCode == OpCodes.Endfinally)&#x200b;</span>
  92:        : <span class="white">                {&#x200b;</span>
  93:        : <span class="white">                    instruction = instruction.Previous;&#x200b;</span>
  94:        : <span class="white">                }&#x200b;</span>
  95:        : <span class="white">                if (instruction.Next.OpCode == OpCodes.Endfinally)&#x200b;</span>
  96:        : <span class="white">                {&#x200b;</span>
  97:        : <span class="white">                    instruction = instruction.Previous;&#x200b;</span>
  98:        : <span class="white">                }&#x200b;</span>
  99:        : <span class="white">                while (instruction.OpCode != OpCodes.Call)&#x200b;</span>
 100:        : <span class="white">                {&#x200b;</span>
 101:        : <span class="white">                    instruction = instruction.Next;&#x200b;</span>
 102:        : <span class="white">                }&#x200b;</span>
 103:        : <span class="white">                var method = ((MethodReference)instruction.Operand);&#x200b;</span>
 104:        : <span class="white">                return method.Name == "Dispose" || method.Name == "System.IDisposable.Dispose";&#x200b;</span>
 105:        : <span class="white">            }&#x200b;</span>
 106:        : <span class="white">            return false;&#x200b;</span>
 107:        : <span class="white">        }&#x200b;</span>
 108:        : <span class="white">&#x200b;</span>
 109:        : <span class="white">        internal static bool ShouldReportSequencePoint(this Instruction instruction)&#x200b;</span>
 110:        : <span class="white">        {&#x200b;</span>
 111:     1/1: <span class="green">            var instructions = new List&lt;Instruction&gt;();&#x200b;</span>
 112:        : <span class="white">            do&#x200b;</span>
 113:        : <span class="white">            {&#x200b;</span>
 114:     9/9: <span class="green">                if (instruction.OpCode != OpCodes.Nop)&#x200b;</span>
 115:        : <span class="white">                {&#x200b;</span>
 116:     3/3: <span class="green">                    instructions.Add(instruction);&#x200b;</span>
 117:        : <span class="white">                }&#x200b;</span>
 118:     3/3: <span class="green">                instruction = instruction.Next;&#x200b;</span>
 119:   13/13: <span class="green">            } while (instruction != null &amp;&amp; instruction.SequencePoint == null);&#x200b;</span>
 120:   10/10: <span class="green">            if (instructions.All(i =&gt; i.OpCode == OpCodes.Ret))&#x200b;</span>
 121:        : <span class="white">            {&#x200b;</span>
 122:     1/1: <span class="green">                return false;&#x200b;</span>
 123:        : <span class="white">            }&#x200b;</span>
 124:     7/7: <span class="green">            if (instructions.Count == 2)&#x200b;</span>
 125:        : <span class="white">            {&#x200b;</span>
 126:     2/2: <span class="green">                Instruction first = instructions[0];&#x200b;</span>
 127:     2/2: <span class="green">                Instruction second = instructions[1];&#x200b;</span>
 128:   29/29: <span class="green">                if (((first.OpCode == OpCodes.Ldarg&#x200b;</span>
 129:   29/29: <span class="green">                    &amp;&amp; ((ParameterDefinition)first.Operand).Sequence == 0 )&#x200b;</span>
 130:   29/29: <span class="green">                    || first.OpCode == OpCodes.Ldarg_0)&#x200b;</span>
 131:   29/29: <span class="green">                    &amp;&amp; second.OpCode == OpCodes.Call&#x200b;</span>
 132:   29/29: <span class="green">                    &amp;&amp; ((MethodReference)second.Operand).Name == Methods.CONSTRUCTOR)&#x200b;</span>
 133:        : <span class="white">                {&#x200b;</span>
 134:     1/1: <span class="green">                    return false;&#x200b;</span>
 135:        : <span class="white">                }&#x200b;</span>
 136:        : <span class="white">            }&#x200b;</span>
 137:     1/1: <span class="green">            return true;&#x200b;</span>
 138:        : <span class="amber">        }&#x200b;</span>
 139:        : <span class="white">    }&#x200b;</span>
 140:        : <span class="white">}&#x200b;</span>
</pre><h1>MethodDefinitionResolver.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Linq;&#x200b;</span>
  24:        : <span class="white">&#x200b;</span>
  25:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">using NLog;&#x200b;</span>
  28:        : <span class="white">&#x200b;</span>
  29:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  30:        : <span class="white">{&#x200b;</span>
  31:        : <span class="white">    internal class MethodDefinitionResolver&#x200b;</span>
  32:        : <span class="white">    {&#x200b;</span>
  33:        : <span class="white">        #region Logging&#x200b;</span>
  34:        : <span class="white">&#x200b;</span>
  35:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();&#x200b;</span>
  36:        : <span class="white">&#x200b;</span>
  37:        : <span class="white">        #endregion&#x200b;</span>
  38:        : <span class="white">&#x200b;</span>
  39:        : <span class="white">        public static MethodDefinition ResolveMethod(TypeDefinition typeDefinition, string methodName)&#x200b;</span>
  40:        : <span class="white">        {&#x200b;</span>
  41:     1/1: <span class="green">            _log.Debug("Resolving method \"{0}\" in \"{1}\".", methodName, typeDefinition.FullName);&#x200b;</span>
  42:        : <span class="white">            try&#x200b;</span>
  43:        : <span class="white">            {&#x200b;</span>
  44:     5/5: <span class="green">                MethodDefinition methodDefinition = typeDefinition.Methods.Single(m =&gt; m.Name == methodName);&#x200b;</span>
  45:     1/1: <span class="green">                _log.Debug("Method \"{0}\" successfully resolved in \"{1}\".", methodName, typeDefinition.FullName);&#x200b;</span>
  46:     3/3: <span class="green">                return methodDefinition;&#x200b;</span>
  47:        : <span class="white">            }&#x200b;</span>
  48:     1/1: <span class="green">            catch (InvalidOperationException ex)&#x200b;</span>
  49:        : <span class="white">            {&#x200b;</span>
  50:     5/5: <span class="green">                if (ex.Message == "Sequence contains no matching element")&#x200b;</span>
  51:        : <span class="white">                {&#x200b;</span>
  52:     1/1: <span class="green">                    _log.Error("Method \"{0}\" is unrecognised.", methodName);&#x200b;</span>
  53:     1/1: <span class="green">                    throw new ArgumentException(string.Format("Method \"{0}\" is unrecognised.", methodName), "methodName");&#x200b;</span>
  54:        : <span class="white">                }&#x200b;</span>
  55:     1/1: <span class="green">                _log.Error("Method \"{0}\" is overloaded.", methodName);&#x200b;</span>
  56:     2/2: <span class="green">                throw new ArgumentException(string.Format("Method \"{0}\" is overloaded.", methodName), "methodName");&#x200b;</span>
  57:        : <span class="white">            }&#x200b;</span>
  58:        : <span class="amber">        }&#x200b;</span>
  59:        : <span class="white">&#x200b;</span>
  60:        : <span class="white">        public static MethodDefinition ResolveMethod(TypeDefinition typeDefinition, string methodName, Type[] parameterTypes)&#x200b;</span>
  61:        : <span class="white">        {&#x200b;</span>
  62:     5/5: <span class="green">            if (parameterTypes == null)&#x200b;</span>
  63:        : <span class="white">            {&#x200b;</span>
  64:     1/1: <span class="green">                _log.Warn("\"ResolveMethod\" overload with parameter types called unnecessarily.");&#x200b;</span>
  65:     2/2: <span class="green">                return ResolveMethod(typeDefinition, methodName);&#x200b;</span>
  66:        : <span class="white">            }&#x200b;</span>
  67:        : <span class="white">            try&#x200b;</span>
  68:        : <span class="white">            {&#x200b;</span>
  69:     5/5: <span class="green">                MethodDefinition methodDefinition =&#x200b;</span>
  70:     5/5: <span class="green">                    typeDefinition.Methods.Single(&#x200b;</span>
  71:     5/5: <span class="green">                        m =&gt; m.Name == methodName&#x200b;</span>
  72:     5/5: <span class="green">                            &amp;&amp; Enumerable.SequenceEqual(&#x200b;</span>
  73:     5/5: <span class="green">                                m.Parameters.Select(p =&gt; p.ParameterType.Name.Replace("TypeDefinition", "Type")),&#x200b;</span>
  74:     5/5: <span class="green">                                parameterTypes.Select(p =&gt; p.Name)));&#x200b;</span>
  75:     1/1: <span class="green">                _log.Debug("Method \"{0}\" successfully resolved in \"{1}\".", methodName, typeDefinition.FullName);&#x200b;</span>
  76:     3/3: <span class="green">                return methodDefinition;&#x200b;</span>
  77:        : <span class="white">            }&#x200b;</span>
  78:        : <span class="amber">            catch (InvalidOperationException)&#x200b;</span>
  79:        : <span class="white">            {&#x200b;</span>
  80:     1/1: <span class="green">                _log.Error("Method \"{0}\" with specified parameter types is unrecognised.", methodName);&#x200b;</span>
  81:     2/2: <span class="green">                throw new ArgumentException(string.Format("Method \"{0}\" with specified parameter types is unrecognised.", methodName), "methodName");&#x200b;</span>
  82:        : <span class="white">            }&#x200b;</span>
  83:        : <span class="amber">        }&#x200b;</span>
  84:        : <span class="white">    }&#x200b;</span>
  85:        : <span class="white">}&#x200b;</span>
</pre><h1>MethodTurtleBase.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Globalization;&#x200b;</span>
  25:        : <span class="white">using System.IO;&#x200b;</span>
  26:        : <span class="white">using System.Linq;&#x200b;</span>
  27:        : <span class="white">&#x200b;</span>
  28:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  29:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  30:        : <span class="white">using Mono.Cecil.Rocks;&#x200b;</span>
  31:        : <span class="white">&#x200b;</span>
  32:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  33:        : <span class="white">{&#x200b;</span>
  34:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  35:        : <span class="white">    /// An abstract base class for implementations of&#x200b;</span>
  36:        : <span class="white">    /// &lt;see cref="IMethodTurtle" /&gt;.&#x200b;</span>
  37:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  38:        : <span class="white">    public abstract class MethodTurtleBase : IMethodTurtle&#x200b;</span>
  39:        : <span class="white">    {&#x200b;</span>
  40:        : <span class="white">        private int[] _originalOffsets;&#x200b;</span>
  41:        : <span class="white">        private Module _module;&#x200b;</span>
  42:        : <span class="white">        private MethodDefinition _method;&#x200b;</span>
  43:        : <span class="white">&#x200b;</span>
  44:        : <span class="white">        internal void MutantComplete(MutantMetaData metaData)&#x200b;</span>
  45:        : <span class="white">        {&#x200b;</span>
  46:     1/1: <span class="green">            metaData.TestDirectory.Dispose();&#x200b;</span>
  47:        : <span class="white">        }&#x200b;</span>
  48:        : <span class="white">&#x200b;</span>
  49:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  50:        : <span class="white">        /// Returns an &lt;see cref="IEnumerable{T}" /&gt; of detailed descriptions&#x200b;</span>
  51:        : <span class="white">        /// of mutations, having first carried out the mutation in question and&#x200b;</span>
  52:        : <span class="white">        /// saved the modified assembly under test to disk.&#x200b;</span>
  53:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  54:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  55:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  56:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  57:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  58:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  59:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  60:        : <span class="white">        /// containing assembly.&#x200b;</span>
  61:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  62:        : <span class="white">        /// &lt;param name="originalOffsets"&gt;&#x200b;</span>
  63:        : <span class="white">        /// An array of the original IL offsets before macros were expanded.&#x200b;</span>
  64:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  65:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  66:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  67:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  68:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  69:        : <span class="white">        public IEnumerable&lt;MutantMetaData&gt; Mutate(MethodDefinition method, Module module, int[] originalOffsets)&#x200b;</span>
  70:        : <span class="white">        {&#x200b;</span>
  71:        : <span class="white">            _module = module;&#x200b;</span>
  72:        : <span class="white">            _method = method;&#x200b;</span>
  73:        : <span class="white">            _originalOffsets = originalOffsets;&#x200b;</span>
  74:        : <span class="white">            method.Body.SimplifyMacros();&#x200b;</span>
  75:        : <span class="white">            foreach (var mutation in DoMutate(method, module))&#x200b;</span>
  76:        : <span class="white">            {&#x200b;</span>
  77:        : <span class="white">                yield return mutation;&#x200b;</span>
  78:        : <span class="white">            }&#x200b;</span>
  79:        : <span class="white">            method.Body.OptimizeMacros();&#x200b;</span>
  80:        : <span class="white">            var nestedType =&#x200b;</span>
  81:        : <span class="white">                method.DeclaringType.NestedTypes.FirstOrDefault(&#x200b;</span>
  82:        : <span class="white">                    t =&gt; t.Name.StartsWith(string.Format("&lt;{0}&gt;", method.Name))&#x200b;</span>
  83:        : <span class="white">                    &amp;&amp; t.Interfaces.Any(i =&gt; i.Name == "IEnumerable`1"));&#x200b;</span>
  84:        : <span class="white">            if (nestedType != null)&#x200b;</span>
  85:        : <span class="white">            {&#x200b;</span>
  86:        : <span class="white">                var nestedMethod = nestedType.Methods.First(m =&gt; m.Name == "MoveNext");&#x200b;</span>
  87:        : <span class="white">                _originalOffsets = nestedMethod.Body.Instructions.Select(i =&gt; i.Offset).ToArray();&#x200b;</span>
  88:        : <span class="white">                _method = nestedMethod;&#x200b;</span>
  89:        : <span class="white">                nestedMethod.Body.SimplifyMacros();&#x200b;</span>
  90:        : <span class="white">                foreach (var mutation in DoMutate(nestedMethod, module))&#x200b;</span>
  91:        : <span class="white">                {&#x200b;</span>
  92:        : <span class="white">                    yield return mutation;&#x200b;</span>
  93:        : <span class="white">                }&#x200b;</span>
  94:        : <span class="white">                nestedMethod.Body.OptimizeMacros();&#x200b;</span>
  95:        : <span class="white">            }&#x200b;</span>
  96:        : <span class="white">        }&#x200b;</span>
  97:        : <span class="white">&#x200b;</span>
  98:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  99:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
 100:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
 101:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 102:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
 103:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
 104:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
 105:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
 106:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
 107:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
 108:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
 109:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 110:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
 111:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
 112:        : <span class="white">        /// containing assembly.&#x200b;</span>
 113:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 114:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
 115:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
 116:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
 117:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
 118:        : <span class="white">        protected abstract IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module);&#x200b;</span>
 119:        : <span class="white">&#x200b;</span>
 120:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 121:        : <span class="white">        /// A helper method that copies the test folder, and saves the mutated&#x200b;</span>
 122:        : <span class="white">        /// assembly under test into it before returning an instance of&#x200b;</span>
 123:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt;.&#x200b;</span>
 124:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 125:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
 126:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
 127:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
 128:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 129:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
 130:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
 131:        : <span class="white">        /// containing assembly.&#x200b;</span>
 132:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 133:        : <span class="white">        /// &lt;param name="description"&gt;&#x200b;</span>
 134:        : <span class="white">        /// A description of the mutation that has been applied.&#x200b;</span>
 135:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 136:        : <span class="white">        /// &lt;param name="index"&gt;&#x200b;</span>
 137:        : <span class="white">        /// The index of the (first) IL instruction at which the mutation was&#x200b;</span>
 138:        : <span class="white">        /// applied.&#x200b;</span>
 139:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 140:        : <span class="white">        /// &lt;returns&gt;&lt;/returns&gt;&#x200b;</span>
 141:        : <span class="white">        protected MutantMetaData DoYield(MethodDefinition method, Module module, string description, int index)&#x200b;</span>
 142:        : <span class="white">        {&#x200b;</span>
 143:     1/1: <span class="green">            var testDirectory = new TestDirectory(Path.GetDirectoryName(module.AssemblyLocation));&#x200b;</span>
 144:     1/1: <span class="green">            testDirectory.SaveAssembly(module);&#x200b;</span>
 145:     7/7: <span class="green">            return new MutantMetaData&#x200b;</span>
 146:     7/7: <span class="green">            {&#x200b;</span>
 147:     7/7: <span class="green">                Description = description,&#x200b;</span>
 148:     7/7: <span class="green">                MethodDefinition = method,&#x200b;</span>
 149:     7/7: <span class="green">                TestDirectory = testDirectory,&#x200b;</span>
 150:     7/7: <span class="green">                ILIndex = index&#x200b;</span>
 151:     7/7: <span class="green">            };&#x200b;</span>
 152:        : <span class="amber">        }&#x200b;</span>
 153:        : <span class="white">&#x200b;</span>
 154:        : <span class="white">        internal int GetOriginalOffset(int index)&#x200b;</span>
 155:        : <span class="white">        {&#x200b;</span>
 156:        : <span class="white">            return _originalOffsets[index];&#x200b;</span>
 157:        : <span class="white">        }&#x200b;</span>
 158:        : <span class="white">&#x200b;</span>
 159:        : <span class="white">        internal string GetOriginalSourceFileName(int index)&#x200b;</span>
 160:        : <span class="white">        {&#x200b;</span>
 161:        : <span class="white">            var sequencePoint = GetCurrentSequencePoint(index);&#x200b;</span>
 162:        : <span class="white">            return Path.GetFileName(sequencePoint.Document.Url);&#x200b;</span>
 163:        : <span class="white">        }&#x200b;</span>
 164:        : <span class="white">&#x200b;</span>
 165:        : <span class="white">        internal SequencePoint GetCurrentSequencePoint(int index)&#x200b;</span>
 166:        : <span class="white">        {&#x200b;</span>
 167:        : <span class="white">            var instruction = _method.Body.Instructions[index];&#x200b;</span>
 168:        : <span class="white">            while ((instruction.SequencePoint == null&#x200b;</span>
 169:        : <span class="white">                || instruction.SequencePoint.StartLine == 0xfeefee) &amp;&amp; index &gt; 0)&#x200b;</span>
 170:        : <span class="white">            {&#x200b;</span>
 171:        : <span class="white">                index--;&#x200b;</span>
 172:        : <span class="white">                instruction = _method.Body.Instructions[index];&#x200b;</span>
 173:        : <span class="white">            }&#x200b;</span>
 174:        : <span class="white">            var sequencePoint = instruction.SequencePoint;&#x200b;</span>
 175:        : <span class="white">            return sequencePoint;&#x200b;</span>
 176:        : <span class="white">        }&#x200b;</span>
 177:        : <span class="white">&#x200b;</span>
 178:        : <span class="white">        internal string GetOriginalSourceCode(int index)&#x200b;</span>
 179:        : <span class="white">        {&#x200b;</span>
 180:        : <span class="white">            var sequencePoint = GetCurrentSequencePoint(index);&#x200b;</span>
 181:        : <span class="white">            string result = "";&#x200b;</span>
 182:        : <span class="white">            if (!_module.SourceFiles.ContainsKey(sequencePoint.Document.Url))&#x200b;</span>
 183:        : <span class="white">            {&#x200b;</span>
 184:        : <span class="white">                return "";&#x200b;</span>
 185:        : <span class="white">            }&#x200b;</span>
 186:        : <span class="white">            string[] sourceCode = _module.SourceFiles[sequencePoint.Document.Url];&#x200b;</span>
 187:        : <span class="white">            int upperBound = Math.Min(sequencePoint.EndLine + 2, sourceCode.Length);&#x200b;</span>
 188:        : <span class="white">            for (int line = Math.Max(sequencePoint.StartLine - 2, 1); line &lt;= upperBound; line++)&#x200b;</span>
 189:        : <span class="white">            {&#x200b;</span>
 190:        : <span class="white">                string sourceLine = sourceCode[line - 1].Replace("\t", "    ");&#x200b;</span>
 191:        : <span class="white">                result += line.ToString(CultureInfo.InvariantCulture)&#x200b;</span>
 192:        : <span class="white">                    .PadLeft(4, ' ') + ": " + sourceLine.TrimEnd(' ', '\t');&#x200b;</span>
 193:        : <span class="white">                if (line &lt; upperBound) result += Environment.NewLine;&#x200b;</span>
 194:        : <span class="white">            }&#x200b;</span>
 195:        : <span class="white">            return result;&#x200b;</span>
 196:        : <span class="white">        }&#x200b;</span>
 197:        : <span class="white">    }&#x200b;</span>
 198:        : <span class="white">}&#x200b;</span>
</pre><h1>Module.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">using System.IO;&#x200b;</span>
  24:        : <span class="white">using System.Linq;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  28:        : <span class="white">using Mono.Cecil.Mdb;&#x200b;</span>
  29:        : <span class="white">using Mono.Cecil.Pdb;&#x200b;</span>
  30:        : <span class="white">using Mono.Collections.Generic;&#x200b;</span>
  31:        : <span class="white">&#x200b;</span>
  32:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  33:        : <span class="white">{&#x200b;</span>
  34:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  35:        : <span class="white">    /// Class representing the main module of a .NET assembly.&#x200b;</span>
  36:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  37:        : <span class="white">    public class Module&#x200b;</span>
  38:        : <span class="white">    {&#x200b;</span>
  39:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  40:        : <span class="white">        /// Initializes a new instance of the &lt;see cref="Module" /&gt; class.&#x200b;</span>
  41:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  42:        : <span class="white">        /// &lt;param name="assemblyLocation"&gt;&#x200b;</span>
  43:        : <span class="white">        /// The location on disk of the assembly whose main module is to be&#x200b;</span>
  44:        : <span class="white">        /// loaded.&#x200b;</span>
  45:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  46:        : <span class="white">        public Module(string assemblyLocation)&#x200b;</span>
  47:        : <span class="white">        {&#x200b;</span>
  48:        : <span class="white">            AssemblyLocation = assemblyLocation;&#x200b;</span>
  49:        : <span class="white">            AssemblyDefinition = AssemblyDefinition.ReadAssembly(assemblyLocation);&#x200b;</span>
  50:        : <span class="white">            Definition = AssemblyDefinition.MainModule;&#x200b;</span>
  51:        : <span class="white">            SourceFiles = new Dictionary&lt;string, string[]&gt;();&#x200b;</span>
  52:        : <span class="white">        }&#x200b;</span>
  53:        : <span class="white">&#x200b;</span>
  54:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  55:        : <span class="white">        /// Gets the location on disk of the assembly.&#x200b;</span>
  56:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  57:        : <span class="white">        public string AssemblyLocation { get; private set; }&#x200b;</span>
  58:        : <span class="white">&#x200b;</span>
  59:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  60:        : <span class="white">        /// Gets the &lt;see cref="AssemblyDefinition" /&gt;.&#x200b;</span>
  61:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  62:        : <span class="white">        public AssemblyDefinition AssemblyDefinition { get; private set; }&#x200b;</span>
  63:        : <span class="white">&#x200b;</span>
  64:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  65:        : <span class="white">        /// Gets the &lt;see cref="ModuleDefinition" /&gt;.&#x200b;</span>
  66:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  67:        : <span class="white">        public ModuleDefinition Definition { get; private set; }&#x200b;</span>
  68:        : <span class="white">&#x200b;</span>
  69:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  70:        : <span class="white">        /// Gets a dictionary of source code files with their contained lines&#x200b;</span>
  71:        : <span class="white">        /// of code.&#x200b;</span>
  72:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  73:        : <span class="white">        public IDictionary&lt;string, string[]&gt; SourceFiles { get; private set; } &#x200b;</span>
  74:        : <span class="white">&#x200b;</span>
  75:        : <span class="white">        internal void LoadDebugInformation()&#x200b;</span>
  76:        : <span class="white">        {&#x200b;</span>
  77:     1/1: <span class="green">            var reader = ResolveSymbolReader();&#x200b;</span>
  78:     6/6: <span class="green">            if (reader == null) return;&#x200b;</span>
  79:        : <span class="white">&#x200b;</span>
  80:     1/1: <span class="green">            Definition.ReadSymbols(reader);&#x200b;</span>
  81:        : <span class="white">&#x200b;</span>
  82:     1/1: <span class="green">            LoadSourceCodeForTypes(Definition.Types, reader);&#x200b;</span>
  83:        : <span class="white">&#x200b;</span>
  84:   19/19: <span class="green">            foreach (var method in Definition.Types&#x200b;</span>
  85:     8/8: <span class="green">                .SelectMany(t =&gt; t.Methods)&#x200b;</span>
  86:     8/8: <span class="green">                .Where(m =&gt; m.HasBody))&#x200b;</span>
  87:        : <span class="white">            {&#x200b;</span>
  88:     1/1: <span class="green">                MethodDefinition capturedMethod = method;&#x200b;</span>
  89:     1/1: <span class="green">                reader.Read(capturedMethod.Body,&#x200b;</span>
  90:     1/1: <span class="green">                    o =&gt; capturedMethod.Body.Instructions.FirstOrDefault(i =&gt; i.Offset &gt;= o));&#x200b;</span>
  91:        : <span class="white">&#x200b;</span>
  92:     7/7: <span class="green">                var sourceFiles = method.Body.Instructions.Where(i =&gt; i.SequencePoint != null)&#x200b;</span>
  93:     7/7: <span class="green">                    .Select(i =&gt; i.SequencePoint.Document.Url)&#x200b;</span>
  94:     7/7: <span class="green">                    .Distinct();&#x200b;</span>
  95:   12/12: <span class="green">                foreach (var sourceFile in sourceFiles)&#x200b;</span>
  96:        : <span class="white">                {&#x200b;</span>
  97:     8/8: <span class="green">                    if (!SourceFiles.ContainsKey(sourceFile) &amp;&amp; File.Exists(sourceFile))&#x200b;</span>
  98:        : <span class="white">                    {&#x200b;</span>
  99:     1/1: <span class="green">                        SourceFiles.Add(sourceFile, File.ReadAllLines(sourceFile));&#x200b;</span>
 100:        : <span class="white">                    }&#x200b;</span>
 101:        : <span class="white">                }&#x200b;</span>
 102:        : <span class="white">            }&#x200b;</span>
 103:        : <span class="white">        }&#x200b;</span>
 104:        : <span class="white">&#x200b;</span>
 105:        : <span class="white">        private void LoadSourceCodeForTypes(Collection&lt;TypeDefinition&gt; types, ISymbolReader reader)&#x200b;</span>
 106:        : <span class="white">        {&#x200b;</span>
 107:        : <span class="white">            foreach (var typeDefinition in types)&#x200b;</span>
 108:        : <span class="white">            {&#x200b;</span>
 109:        : <span class="white">                foreach (var method in typeDefinition.Methods.Where(m =&gt; m.HasBody))&#x200b;</span>
 110:        : <span class="white">                {&#x200b;</span>
 111:        : <span class="white">                    MethodDefinition capturedMethod = method;&#x200b;</span>
 112:        : <span class="white">                    reader.Read(capturedMethod.Body,&#x200b;</span>
 113:        : <span class="white">                        o =&gt; capturedMethod.Body.Instructions.FirstOrDefault(i =&gt; i.Offset &gt;= o));&#x200b;</span>
 114:        : <span class="white">&#x200b;</span>
 115:        : <span class="white">                    var sourceFiles = method.Body.Instructions.Where(i =&gt; i.SequencePoint != null)&#x200b;</span>
 116:        : <span class="white">                        .Select(i =&gt; i.SequencePoint.Document.Url)&#x200b;</span>
 117:        : <span class="white">                        .Distinct();&#x200b;</span>
 118:        : <span class="white">                    foreach (var sourceFile in sourceFiles)&#x200b;</span>
 119:        : <span class="white">                    {&#x200b;</span>
 120:        : <span class="white">                        if (!SourceFiles.ContainsKey(sourceFile) &amp;&amp; File.Exists(sourceFile))&#x200b;</span>
 121:        : <span class="white">                        {&#x200b;</span>
 122:        : <span class="white">                            SourceFiles.Add(sourceFile, File.ReadAllLines(sourceFile));&#x200b;</span>
 123:        : <span class="white">                        }&#x200b;</span>
 124:        : <span class="white">                    }&#x200b;</span>
 125:        : <span class="white">                }&#x200b;</span>
 126:        : <span class="white">                if (typeDefinition.NestedTypes != null)&#x200b;</span>
 127:        : <span class="white">                {&#x200b;</span>
 128:        : <span class="white">                    LoadSourceCodeForTypes(typeDefinition.NestedTypes, reader);&#x200b;</span>
 129:        : <span class="white">                }&#x200b;</span>
 130:        : <span class="white">            }&#x200b;</span>
 131:        : <span class="white">        }&#x200b;</span>
 132:        : <span class="white">&#x200b;</span>
 133:        : <span class="white">        private ISymbolReader ResolveSymbolReader()&#x200b;</span>
 134:        : <span class="white">        {&#x200b;</span>
 135:        : <span class="white">            string symbolLocation = null;&#x200b;</span>
 136:        : <span class="white">            string pdbLocation = Path.ChangeExtension(AssemblyLocation, "pdb");&#x200b;</span>
 137:        : <span class="white">            string mdbLocation = AssemblyLocation + ".mdb";&#x200b;</span>
 138:        : <span class="white">            ISymbolReaderProvider provider = null;&#x200b;</span>
 139:        : <span class="white">            if (File.Exists(pdbLocation))&#x200b;</span>
 140:        : <span class="white">            {&#x200b;</span>
 141:        : <span class="white">                symbolLocation = pdbLocation;&#x200b;</span>
 142:        : <span class="white">                provider = new PdbReaderProvider();&#x200b;</span>
 143:        : <span class="white">            }&#x200b;</span>
 144:        : <span class="white">            else if (File.Exists(mdbLocation))&#x200b;</span>
 145:        : <span class="white">            {&#x200b;</span>
 146:        : <span class="white">                symbolLocation = AssemblyLocation;&#x200b;</span>
 147:        : <span class="white">                provider = new MdbReaderProvider();&#x200b;</span>
 148:        : <span class="white">            }&#x200b;</span>
 149:        : <span class="white">            if (provider == null) return null;&#x200b;</span>
 150:        : <span class="white">            var reader = provider.GetSymbolReader(Definition, symbolLocation);&#x200b;</span>
 151:        : <span class="white">            return reader;&#x200b;</span>
 152:        : <span class="white">        }&#x200b;</span>
 153:        : <span class="white">    }&#x200b;</span>
 154:        : <span class="white">}&#x200b;</span>
</pre><h1>MutationTest.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Diagnostics;&#x200b;</span>
  25:        : <span class="white">using System.IO;&#x200b;</span>
  26:        : <span class="white">using System.Linq;&#x200b;</span>
  27:        : <span class="white">using System.Management;&#x200b;</span>
  28:        : <span class="white">using System.Text.RegularExpressions;&#x200b;</span>
  29:        : <span class="white">using System.Threading;&#x200b;</span>
  30:        : <span class="white">using System.Threading.Tasks;&#x200b;</span>
  31:        : <span class="white">using System.Xml.Serialization;&#x200b;</span>
  32:        : <span class="white">&#x200b;</span>
  33:        : <span class="white">using Microsoft.Win32;&#x200b;</span>
  34:        : <span class="white">&#x200b;</span>
  35:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  36:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  37:        : <span class="white">using Mono.Collections.Generic;&#x200b;</span>
  38:        : <span class="white">&#x200b;</span>
  39:        : <span class="white">using NinjaTurtles.Reporting;&#x200b;</span>
  40:        : <span class="white">using NinjaTurtles.TestRunners;&#x200b;</span>
  41:        : <span class="white">using NinjaTurtles.Turtles;&#x200b;</span>
  42:        : <span class="white">&#x200b;</span>
  43:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  44:        : <span class="white">{&#x200b;</span>
  45:        : <span class="white">    internal class MutationTest : IMutationTest&#x200b;</span>
  46:        : <span class="white">    {&#x200b;</span>
  47:        : <span class="white">        private const string ERROR_REPORTING_KEY = @"SOFTWARE\Microsoft\Windows\Windows Error Reporting";&#x200b;</span>
  48:        : <span class="white">        private const string ERROR_REPORTING_VALUE = "DontShowUI";&#x200b;</span>
  49:        : <span class="white">&#x200b;</span>
  50:        : <span class="white">        private readonly IList&lt;Type&gt; _mutationsToApply = new List&lt;Type&gt;();&#x200b;</span>
  51:        : <span class="white">        private readonly string _testAssemblyLocation;&#x200b;</span>
  52:        : <span class="white">        private readonly Type[] _parameterTypes;&#x200b;</span>
  53:        : <span class="white">        private readonly AssemblyDefinition _testAssembly;&#x200b;</span>
  54:        : <span class="white">        private readonly TypeReference _targetTypeReference;&#x200b;</span>
  55:        : <span class="white">        private Module _module;&#x200b;</span>
  56:        : <span class="white">        private IEnumerable&lt;string&gt; _testsToRun;&#x200b;</span>
  57:        : <span class="white">        private ITestRunner _runner;&#x200b;</span>
  58:        : <span class="white">        private MutationTestingReport _report;&#x200b;</span>
  59:        : <span class="white">        private ReportingStrategy _reportingStrategy = new NullReportingStrategy();&#x200b;</span>
  60:        : <span class="white">        private string _reportFileName;&#x200b;</span>
  61:        : <span class="white">        private MethodReferenceComparer _comparer;&#x200b;</span>
  62:        : <span class="white">        private static Regex _automaticallyGeneratedNestedClassMatcher = new Regex("^\\&lt;([A-Za-z0-9@_]+)\\&gt;");&#x200b;</span>
  63:        : <span class="white">        //private TimeSpan _benchmark;&#x200b;</span>
  64:        : <span class="white">&#x200b;</span>
  65:        : <span class="white">        internal MutationTest(string testAssemblyLocation, Type targetType, string targetMethod, Type[] parameterTypes)&#x200b;</span>
  66:        : <span class="white">        {&#x200b;</span>
  67:        : <span class="white">            TargetType = targetType;&#x200b;</span>
  68:        : <span class="white">            TargetMethod = targetMethod;&#x200b;</span>
  69:        : <span class="white">            _testAssemblyLocation = testAssemblyLocation;&#x200b;</span>
  70:        : <span class="white">            _parameterTypes = parameterTypes;&#x200b;</span>
  71:        : <span class="white">            _testAssembly = AssemblyDefinition.ReadAssembly(testAssemblyLocation);&#x200b;</span>
  72:        : <span class="white">            _targetTypeReference = _testAssembly.MainModule.Import(targetType);&#x200b;</span>
  73:        : <span class="white">        }&#x200b;</span>
  74:        : <span class="white">        &#x200b;</span>
  75:        : <span class="white">        public Type TargetType { get; private set; }&#x200b;</span>
  76:        : <span class="white">&#x200b;</span>
  77:        : <span class="white">        public string TargetMethod { get; private set; }&#x200b;</span>
  78:        : <span class="white">        &#x200b;</span>
  79:        : <span class="white">        public void Run()&#x200b;</span>
  80:        : <span class="white">        {&#x200b;</span>
  81:     1/1: <span class="green">            var key = Registry.LocalMachine.OpenSubKey(ERROR_REPORTING_KEY, RegistryKeyPermissionCheck.ReadWriteSubTree);&#x200b;</span>
  82:     1/1: <span class="green">            var errorReportingValue = key.GetValue(ERROR_REPORTING_VALUE, null);&#x200b;</span>
  83:     1/1: <span class="green">            key.SetValue(ERROR_REPORTING_VALUE, 1, RegistryValueKind.DWord);&#x200b;</span>
  84:     1/1: <span class="green">            key.Close();&#x200b;</span>
  85:        : <span class="white">&#x200b;</span>
  86:     1/1: <span class="green">            MethodDefinition method = ValidateMethod();&#x200b;</span>
  87:     1/1: <span class="green">            _module.LoadDebugInformation();&#x200b;</span>
  88:        : <span class="white">&#x200b;</span>
  89:     1/1: <span class="green">            _comparer = new MethodReferenceComparer();&#x200b;</span>
  90:     1/1: <span class="green">            var matchingMethods = new List&lt;MethodReference&gt;();&#x200b;</span>
  91:     1/1: <span class="green">            AddMethod(method, matchingMethods);&#x200b;</span>
  92:        : <span class="white">&#x200b;</span>
  93:     4/4: <span class="green">            int[] originalOffsets = method.Body.Instructions.Select(i =&gt; i.Offset).ToArray();&#x200b;</span>
  94:     1/1: <span class="green">            _report = new MutationTestingReport();&#x200b;</span>
  95:     1/1: <span class="green">            _testsToRun = GetMatchingTestsFromTree(method, matchingMethods);&#x200b;</span>
  96:        : <span class="white">&#x200b;</span>
  97:        : <span class="white">            //_benchmark = BenchmarkTestSuite();&#x200b;</span>
  98:        : <span class="white">&#x200b;</span>
  99:     1/1: <span class="green">            int count = 0;&#x200b;</span>
 100:     1/1: <span class="green">            int failures = 0;&#x200b;</span>
 101:     6/6: <span class="green">            if (_mutationsToApply.Count == 0) PopulateDefaultTurtles();&#x200b;</span>
 102:   13/13: <span class="green">            foreach (var turtleType in _mutationsToApply)&#x200b;</span>
 103:        : <span class="white">            {&#x200b;</span>
 104:     1/1: <span class="green">                var turtle = (MethodTurtleBase)Activator.CreateInstance(turtleType);&#x200b;</span>
 105:     1/1: <span class="green">                Parallel.ForEach(turtle.Mutate(method, _module, originalOffsets),&#x200b;</span>
 106:     1/1: <span class="green">                    mutation =&gt; RunMutation(turtle, mutation, ref failures, ref count));&#x200b;</span>
 107:        : <span class="white">            }&#x200b;</span>
 108:        : <span class="white">&#x200b;</span>
 109:     1/1: <span class="green">            _report.RegisterMethod(method);&#x200b;</span>
 110:     1/1: <span class="green">            _reportingStrategy.WriteReport(_report, _reportFileName);&#x200b;</span>
 111:        : <span class="white">&#x200b;</span>
 112:     1/1: <span class="green">            key = Registry.LocalMachine.OpenSubKey(ERROR_REPORTING_KEY, RegistryKeyPermissionCheck.ReadWriteSubTree);&#x200b;</span>
 113:     5/5: <span class="green">            if (errorReportingValue == null)&#x200b;</span>
 114:        : <span class="white">            {&#x200b;</span>
 115:     1/1: <span class="green">                key.DeleteValue(ERROR_REPORTING_VALUE);&#x200b;</span>
 116:     1/1: <span class="green">            }&#x200b;</span>
 117:        : <span class="white">            else&#x200b;</span>
 118:        : <span class="white">            {&#x200b;</span>
 119:     1/1: <span class="green">                key.SetValue(ERROR_REPORTING_VALUE, errorReportingValue, RegistryValueKind.DWord);&#x200b;</span>
 120:        : <span class="white">            }&#x200b;</span>
 121:     1/1: <span class="green">            key.Close();&#x200b;</span>
 122:        : <span class="white">&#x200b;</span>
 123:     5/5: <span class="green">            if (count == 0)&#x200b;</span>
 124:        : <span class="white">            {&#x200b;</span>
 125:     1/1: <span class="green">                Console.WriteLine("No valid mutations found (this is fine).");&#x200b;</span>
 126:     1/1: <span class="green">                return;&#x200b;</span>
 127:        : <span class="white">            }&#x200b;</span>
 128:     6/6: <span class="green">            if (failures &gt; 0)&#x200b;</span>
 129:        : <span class="white">            {&#x200b;</span>
 130:     1/1: <span class="green">                throw new MutationTestFailureException();&#x200b;</span>
 131:        : <span class="white">            }&#x200b;</span>
 132:        : <span class="white">        }&#x200b;</span>
 133:        : <span class="white">&#x200b;</span>
 134:        : <span class="white">        private void AddMethod(MethodDefinition targetMethod, List&lt;MethodReference&gt; matchingMethods)&#x200b;</span>
 135:        : <span class="white">        {&#x200b;</span>
 136:        : <span class="white">            if (matchingMethods.Contains(targetMethod, _comparer)) return;&#x200b;</span>
 137:        : <span class="white">            matchingMethods.Add(targetMethod);&#x200b;</span>
 138:        : <span class="white">            AddCallingMethods(targetMethod, matchingMethods);&#x200b;</span>
 139:        : <span class="white">            var declaringType = targetMethod.DeclaringType;&#x200b;</span>
 140:        : <span class="white">            TypeDefinition type = declaringType;&#x200b;</span>
 141:        : <span class="white">            while (type != null &amp;&amp; type.BaseType != null)&#x200b;</span>
 142:        : <span class="white">            {&#x200b;</span>
 143:        : <span class="white">                var thisModule = type.BaseType.Module;&#x200b;</span>
 144:        : <span class="white">                if (type.BaseType.Scope.Name != type.BaseType.Module.Assembly.Name.Name&#x200b;</span>
 145:        : <span class="white">                    &amp;&amp; type.BaseType.Scope is AssemblyNameReference)&#x200b;</span>
 146:        : <span class="white">                {&#x200b;</span>
 147:        : <span class="white">                    thisModule =&#x200b;</span>
 148:        : <span class="white">                        type.BaseType.Module.AssemblyResolver.Resolve((AssemblyNameReference)type.BaseType.Scope).&#x200b;</span>
 149:        : <span class="white">                            MainModule;&#x200b;</span>
 150:        : <span class="white">                }&#x200b;</span>
 151:        : <span class="white">                type = thisModule.Types.SingleOrDefault(t =&gt; t.FullName == type.BaseType.FullName);&#x200b;</span>
 152:        : <span class="white">                if (type != null)&#x200b;</span>
 153:        : <span class="white">                {&#x200b;</span>
 154:        : <span class="white">                    var baseMethod = type.Methods&#x200b;</span>
 155:        : <span class="white">                        .SingleOrDefault(m =&gt; MethodsMatch(m, targetMethod));&#x200b;</span>
 156:        : <span class="white">                    if (baseMethod != null)&#x200b;</span>
 157:        : <span class="white">                    {&#x200b;</span>
 158:        : <span class="white">                        AddMethod(baseMethod, matchingMethods);&#x200b;</span>
 159:        : <span class="white">                        break;&#x200b;</span>
 160:        : <span class="white">                    }&#x200b;</span>
 161:        : <span class="white">                    AddMethodsForInterfaces(targetMethod, matchingMethods, type);&#x200b;</span>
 162:        : <span class="white">                }&#x200b;</span>
 163:        : <span class="white">            }&#x200b;</span>
 164:        : <span class="white">            AddMethodsForInterfaces(targetMethod, matchingMethods, declaringType);&#x200b;</span>
 165:        : <span class="white">        }&#x200b;</span>
 166:        : <span class="white">&#x200b;</span>
 167:        : <span class="white">        private void AddMethodsForInterfaces(MethodDefinition targetMethod, List&lt;MethodReference&gt; matchingMethods, TypeDefinition type)&#x200b;</span>
 168:        : <span class="white">        {&#x200b;</span>
 169:        : <span class="white">            foreach (var interfaceReference in type.Interfaces)&#x200b;</span>
 170:        : <span class="white">            {&#x200b;</span>
 171:        : <span class="white">                var thisModule = type.Module;&#x200b;</span>
 172:        : <span class="white">                if (interfaceReference.Scope.Name != type.Module.Assembly.Name.Name&#x200b;</span>
 173:        : <span class="white">                    &amp;&amp; interfaceReference.Scope is AssemblyNameReference)&#x200b;</span>
 174:        : <span class="white">                {&#x200b;</span>
 175:        : <span class="white">                    thisModule =&#x200b;</span>
 176:        : <span class="white">                        interfaceReference.Module.AssemblyResolver.Resolve((AssemblyNameReference)interfaceReference.Scope).&#x200b;</span>
 177:        : <span class="white">                            MainModule;&#x200b;</span>
 178:        : <span class="white">                }&#x200b;</span>
 179:        : <span class="white">                var interfaceDefinition =&#x200b;</span>
 180:        : <span class="white">                    thisModule.Types.SingleOrDefault(t =&gt; t.FullName == interfaceReference.FullName);&#x200b;</span>
 181:        : <span class="white">                if (interfaceDefinition != null)&#x200b;</span>
 182:        : <span class="white">                {&#x200b;</span>
 183:        : <span class="white">                    var interfaceMethod = interfaceDefinition.Methods&#x200b;</span>
 184:        : <span class="white">                        .SingleOrDefault(m =&gt; MethodsMatch(m, targetMethod));&#x200b;</span>
 185:        : <span class="white">                    if (interfaceMethod != null)&#x200b;</span>
 186:        : <span class="white">                    {&#x200b;</span>
 187:        : <span class="white">                        AddMethod(interfaceMethod, matchingMethods);&#x200b;</span>
 188:        : <span class="white">                    }&#x200b;</span>
 189:        : <span class="white">                }&#x200b;</span>
 190:        : <span class="white">            }&#x200b;</span>
 191:        : <span class="white">        }&#x200b;</span>
 192:        : <span class="white">&#x200b;</span>
 193:        : <span class="white">        private bool MethodsMatch(MethodDefinition first, MethodDefinition second)&#x200b;</span>
 194:        : <span class="white">        {&#x200b;</span>
 195:   18/18: <span class="green">            return first.Name == second.Name&#x200b;</span>
 196:   18/18: <span class="green">                   &amp;&amp; Enumerable.SequenceEqual(first.Parameters.Select(p =&gt; p.ParameterType.Name),&#x200b;</span>
 197:   18/18: <span class="green">                                               second.Parameters.Select(p =&gt; p.ParameterType.Name))&#x200b;</span>
 198:   18/18: <span class="green">                   &amp;&amp; first.GenericParameters.Count == second.GenericParameters.Count;&#x200b;</span>
 199:        : <span class="amber">        }&#x200b;</span>
 200:        : <span class="white">&#x200b;</span>
 201:        : <span class="white">        private ISet&lt;string&gt; GetMatchingTestsFromTree(MethodDefinition targetmethod, IList&lt;MethodReference&gt; matchingMethods, bool force = false)&#x200b;</span>
 202:        : <span class="white">        {&#x200b;</span>
 203:     1/1: <span class="green">            ISet&lt;string&gt; result = new HashSet&lt;string&gt;();&#x200b;</span>
 204:   10/10: <span class="green">            foreach (var type in _testAssembly.MainModule.Types)&#x200b;</span>
 205:     2/2: <span class="green">            AddTestsForType(targetmethod, matchingMethods, force, type, result);&#x200b;</span>
 206:   10/10: <span class="green">            if (!force &amp;&amp; result.Count == 0)&#x200b;</span>
 207:        : <span class="white">            {&#x200b;</span>
 208:     1/1: <span class="green">                result = GetMatchingTestsFromTree(targetmethod, matchingMethods, true);&#x200b;</span>
 209:        : <span class="white">            }&#x200b;</span>
 210:     6/6: <span class="green">            if (result.Count == 0)&#x200b;</span>
 211:        : <span class="white">            {&#x200b;</span>
 212:     1/1: <span class="green">                throw new MutationTestFailureException(&#x200b;</span>
 213:     1/1: <span class="green">                    "No matching tests were found to run.");&#x200b;</span>
 214:        : <span class="white">            }&#x200b;</span>
 215:        : <span class="amber">            return result;&#x200b;</span>
 216:        : <span class="amber">        }&#x200b;</span>
 217:        : <span class="white">&#x200b;</span>
 218:        : <span class="white">        private void AddTestsForType(MethodDefinition targetmethod, IList&lt;MethodReference&gt; matchingMethods, bool force, TypeDefinition type,&#x200b;</span>
 219:        : <span class="white">                                     ISet&lt;string&gt; result)&#x200b;</span>
 220:        : <span class="white">        {&#x200b;</span>
 221:        : <span class="white">            foreach (var method in type.Methods.Where(m =&gt; m.HasBody))&#x200b;</span>
 222:        : <span class="white">            {&#x200b;</span>
 223:        : <span class="white">                var targetType = targetmethod.DeclaringType.FullName;&#x200b;</span>
 224:        : <span class="white">                if (!force &amp;&amp; !DoesMethodReferenceType(method, targetType)) continue;&#x200b;</span>
 225:        : <span class="white">                foreach (var instruction in method.Body.Instructions)&#x200b;</span>
 226:        : <span class="white">                {&#x200b;</span>
 227:        : <span class="white">                    if (instruction.OpCode == OpCodes.Call&#x200b;</span>
 228:        : <span class="white">                        || instruction.OpCode == OpCodes.Callvirt&#x200b;</span>
 229:        : <span class="white">                        || instruction.OpCode == OpCodes.Newobj&#x200b;</span>
 230:        : <span class="white">                        || instruction.OpCode == OpCodes.Ldftn)&#x200b;</span>
 231:        : <span class="white">                    {&#x200b;</span>
 232:        : <span class="white">                        var reference = (MethodReference)instruction.Operand;&#x200b;</span>
 233:        : <span class="white">                        if (matchingMethods.Any(m =&gt; _comparer.Equals(m, reference))&#x200b;</span>
 234:        : <span class="white">                            &amp;&amp; !method.CustomAttributes.Any(a =&gt; a.AttributeType.Name == "MutationTestAttribute"))&#x200b;</span>
 235:        : <span class="white">                        {&#x200b;</span>
 236:        : <span class="white">                            result.Add(string.Format("{0}.{1}", type.FullName.Replace("/", "+"), method.Name));&#x200b;</span>
 237:        : <span class="white">                            break;&#x200b;</span>
 238:        : <span class="white">                        }&#x200b;</span>
 239:        : <span class="white">                    }&#x200b;</span>
 240:        : <span class="white">                }&#x200b;</span>
 241:        : <span class="white">            }&#x200b;</span>
 242:        : <span class="white">            if (type.NestedTypes != null)&#x200b;</span>
 243:        : <span class="white">            {&#x200b;</span>
 244:        : <span class="white">                foreach (var typeDefinition in type.NestedTypes)&#x200b;</span>
 245:        : <span class="white">                {&#x200b;</span>
 246:        : <span class="white">                    AddTestsForType(targetmethod, matchingMethods, force, typeDefinition, result);&#x200b;</span>
 247:        : <span class="white">                }&#x200b;</span>
 248:        : <span class="white">            }&#x200b;</span>
 249:        : <span class="white">        }&#x200b;</span>
 250:        : <span class="white">&#x200b;</span>
 251:        : <span class="white">        private static bool DoesMethodReferenceType(MethodDefinition method, string targetType)&#x200b;</span>
 252:        : <span class="white">        {&#x200b;</span>
 253:     1/1: <span class="green">            bool typeUsed = false;&#x200b;</span>
 254:   13/13: <span class="green">            foreach (var instruction in method.Body.Instructions)&#x200b;</span>
 255:        : <span class="white">            {&#x200b;</span>
 256:   16/16: <span class="green">                if (instruction.OpCode == OpCodes.Call&#x200b;</span>
 257:   16/16: <span class="green">                    || instruction.OpCode == OpCodes.Callvirt&#x200b;</span>
 258:   16/16: <span class="green">                    || instruction.OpCode == OpCodes.Newobj&#x200b;</span>
 259:   16/16: <span class="green">                    || instruction.OpCode == OpCodes.Ldftn)&#x200b;</span>
 260:        : <span class="white">                {&#x200b;</span>
 261:     1/1: <span class="green">                    var reference = (MethodReference)instruction.Operand;&#x200b;</span>
 262:     1/1: <span class="green">                    var declaringType = reference.DeclaringType;&#x200b;</span>
 263:     9/9: <span class="green">                    if (declaringType.FullName == targetType)&#x200b;</span>
 264:        : <span class="white">                    {&#x200b;</span>
 265:     3/3: <span class="green">                        typeUsed = true;&#x200b;</span>
 266:     1/1: <span class="green">                        break;&#x200b;</span>
 267:        : <span class="white">                    }&#x200b;</span>
 268:     1/1: <span class="green">                    var genericType = declaringType as GenericInstanceType;&#x200b;</span>
 269:     9/9: <span class="green">                    if (genericType != null)&#x200b;</span>
 270:        : <span class="white">                    {&#x200b;</span>
 271:   12/12: <span class="green">                        if (genericType.GenericArguments.Any(a =&gt; a.FullName == targetType))&#x200b;</span>
 272:        : <span class="white">                        {&#x200b;</span>
 273:     3/3: <span class="green">                            typeUsed = true;&#x200b;</span>
 274:     1/1: <span class="green">                            break;&#x200b;</span>
 275:        : <span class="white">                        }&#x200b;</span>
 276:        : <span class="white">                    }&#x200b;</span>
 277:     1/1: <span class="green">                    var genericMethod = reference as GenericInstanceMethod;&#x200b;</span>
 278:     9/9: <span class="green">                    if (genericMethod != null)&#x200b;</span>
 279:        : <span class="white">                    {&#x200b;</span>
 280:   12/12: <span class="green">                        if (genericMethod.GenericArguments.Any(a =&gt; a.FullName == targetType))&#x200b;</span>
 281:        : <span class="white">                        {&#x200b;</span>
 282:     3/3: <span class="green">                            typeUsed = true;&#x200b;</span>
 283:     1/1: <span class="green">                            break;&#x200b;</span>
 284:        : <span class="white">                        }&#x200b;</span>
 285:        : <span class="white">                    }&#x200b;</span>
 286:        : <span class="white">                }&#x200b;</span>
 287:     9/9: <span class="green">                if (instruction.OpCode == OpCodes.Newobj)&#x200b;</span>
 288:        : <span class="white">                {&#x200b;</span>
 289:     1/1: <span class="green">                    var constructor = (MemberReference)instruction.Operand;&#x200b;</span>
 290:     1/1: <span class="green">                    var declaringType = constructor.DeclaringType;&#x200b;</span>
 291:     9/9: <span class="green">                    if (declaringType.FullName == targetType)&#x200b;</span>
 292:        : <span class="white">                    {&#x200b;</span>
 293:     3/3: <span class="green">                        typeUsed = true;&#x200b;</span>
 294:     1/1: <span class="green">                        break;&#x200b;</span>
 295:        : <span class="white">                    }&#x200b;</span>
 296:        : <span class="white">                }&#x200b;</span>
 297:        : <span class="white">            }&#x200b;</span>
 298:     4/4: <span class="green">            return typeUsed;&#x200b;</span>
 299:        : <span class="amber">        }&#x200b;</span>
 300:        : <span class="white">&#x200b;</span>
 301:        : <span class="white">        private void AddCallingMethods(MethodReference targetMethod, List&lt;MethodReference&gt; matchingMethods)&#x200b;</span>
 302:        : <span class="white">        {&#x200b;</span>
 303:     9/9: <span class="green">            foreach (var type in _module.Definition.Types)&#x200b;</span>
 304:     1/1: <span class="green">            AddCallingMethodsForType(targetMethod, matchingMethods, type);&#x200b;</span>
 305:        : <span class="white">        }&#x200b;</span>
 306:        : <span class="white">&#x200b;</span>
 307:        : <span class="white">        private void AddCallingMethodsForType(MethodReference targetMethod, List&lt;MethodReference&gt; matchingMethods, TypeDefinition type)&#x200b;</span>
 308:        : <span class="white">        {&#x200b;</span>
 309:   16/16: <span class="green">            foreach (var method in type.Methods.Where(m =&gt; m.HasBody))&#x200b;</span>
 310:     9/9: <span class="green">            foreach (var instruction in method.Body.Instructions)&#x200b;</span>
 311:        : <span class="white">            {&#x200b;</span>
 312:   14/14: <span class="green">                if (instruction.OpCode == OpCodes.Call&#x200b;</span>
 313:   14/14: <span class="green">                    || instruction.OpCode == OpCodes.Callvirt&#x200b;</span>
 314:   14/14: <span class="green">                    || instruction.OpCode == OpCodes.Newobj&#x200b;</span>
 315:   14/14: <span class="green">                    || instruction.OpCode == OpCodes.Ldftn)&#x200b;</span>
 316:        : <span class="white">                {&#x200b;</span>
 317:     1/1: <span class="green">                    var reference = (MethodReference)instruction.Operand;&#x200b;</span>
 318:   10/10: <span class="green">                    if (_comparer.Equals(reference, targetMethod)&#x200b;</span>
 319:   10/10: <span class="green">                        &amp;&amp; !matchingMethods.Contains(method, _comparer))&#x200b;</span>
 320:        : <span class="white">                    {&#x200b;</span>
 321:     1/1: <span class="green">                        AddMethod(method, matchingMethods);&#x200b;</span>
 322:     2/2: <span class="green">                        var match = _automaticallyGeneratedNestedClassMatcher.Match(type.Name);&#x200b;</span>
 323:     9/9: <span class="green">                        if (match.Success &amp;&amp; type.DeclaringType != null)&#x200b;</span>
 324:        : <span class="white">                        {&#x200b;</span>
 325:     9/9: <span class="green">                            if (type.DeclaringType.Methods.Any(m =&gt; m.Name == match.Groups[1].Value))&#x200b;</span>
 326:        : <span class="white">                            {&#x200b;</span>
 327:     5/5: <span class="green">                                AddMethod(type.DeclaringType.Methods.First(m =&gt; m.Name == match.Groups[1].Value), matchingMethods);&#x200b;</span>
 328:        : <span class="white">                            }&#x200b;</span>
 329:        : <span class="white">                        }&#x200b;</span>
 330:        : <span class="white">                    }&#x200b;</span>
 331:        : <span class="white">                }&#x200b;</span>
 332:        : <span class="white">            }&#x200b;</span>
 333:   10/10: <span class="green">            foreach (var nestedType in type.NestedTypes)&#x200b;</span>
 334:        : <span class="white">            {&#x200b;</span>
 335:     3/3: <span class="green">                AddCallingMethodsForType(targetMethod, matchingMethods, nestedType);&#x200b;</span>
 336:        : <span class="white">            }&#x200b;</span>
 337:        : <span class="white">        }&#x200b;</span>
 338:        : <span class="white">&#x200b;</span>
 339:        : <span class="white">        private class MethodReferenceComparer : IEqualityComparer&lt;MethodReference&gt;&#x200b;</span>
 340:        : <span class="white">        {&#x200b;</span>
 341:        : <span class="white">            public bool Equals(MethodReference x, MethodReference y)&#x200b;</span>
 342:        : <span class="white">            {&#x200b;</span>
 343:        : <span class="white">                if (x.Name != y.Name) return false;&#x200b;</span>
 344:        : <span class="white">                        return x.DeclaringType.FullName == y.DeclaringType.FullName&#x200b;</span>
 345:        : <span class="white">                        &amp;&amp; Enumerable.SequenceEqual(x.Parameters.Select(p =&gt; p.ParameterType.Name),&#x200b;</span>
 346:        : <span class="white">                                                 y.Parameters.Select(p =&gt; p.ParameterType.Name))&#x200b;</span>
 347:        : <span class="white">                        &amp;&amp; x.GenericParameters.Count == y.GenericParameters.Count;&#x200b;</span>
 348:        : <span class="white">            }&#x200b;</span>
 349:        : <span class="white">&#x200b;</span>
 350:        : <span class="white">            public int GetHashCode(MethodReference obj)&#x200b;</span>
 351:        : <span class="white">            {&#x200b;</span>
 352:        : <span class="white">                return obj.Name.GetHashCode();&#x200b;</span>
 353:        : <span class="white">            }&#x200b;</span>
 354:        : <span class="white">        }&#x200b;</span>
 355:        : <span class="white">&#x200b;</span>
 356:        : <span class="white">        private void RunMutation(MethodTurtleBase turtle, MutantMetaData mutation, ref int failures, ref int count)&#x200b;</span>
 357:        : <span class="white">        {&#x200b;</span>
 358:     2/2: <span class="green">            bool testProcessFailed = CheckTestProcessFails(turtle, mutation);&#x200b;</span>
 359:     8/8: <span class="green">            if (!testProcessFailed)&#x200b;</span>
 360:        : <span class="white">            {&#x200b;</span>
 361:     1/1: <span class="green">                Interlocked.Increment(ref failures);&#x200b;</span>
 362:        : <span class="white">            }&#x200b;</span>
 363:     1/1: <span class="green">            Interlocked.Increment(ref count);&#x200b;</span>
 364:        : <span class="white">        }&#x200b;</span>
 365:        : <span class="white">&#x200b;</span>
 366:        : <span class="white">//        private TimeSpan BenchmarkTestSuite()&#x200b;</span>
 367:        : <span class="white">//        {&#x200b;</span>
 368:        : <span class="white">//            var testDirectory = new TestDirectory(Path.GetDirectoryName(_testAssemblyLocation));&#x200b;</span>
 369:        : <span class="white">//&#x200b;</span>
 370:        : <span class="white">//            var process = GetTestRunnerProcess(testDirectory);&#x200b;</span>
 371:        : <span class="white">//&#x200b;</span>
 372:        : <span class="white">//            var stopwatch = new Stopwatch();&#x200b;</span>
 373:        : <span class="white">//            stopwatch.Start();&#x200b;</span>
 374:        : <span class="white">//            process.Start();&#x200b;</span>
 375:        : <span class="white">//            process.WaitForExit();&#x200b;</span>
 376:        : <span class="white">//            stopwatch.Stop();&#x200b;</span>
 377:        : <span class="white">//&#x200b;</span>
 378:        : <span class="white">//            testDirectory.Dispose();&#x200b;</span>
 379:        : <span class="white">//&#x200b;</span>
 380:        : <span class="white">//            if (process.ExitCode != 0)&#x200b;</span>
 381:        : <span class="white">//            {&#x200b;</span>
 382:        : <span class="white">//                throw new MutationTestFailureException("Test suite does not pass with unmutated code - mutation testing aborted.");&#x200b;</span>
 383:        : <span class="white">//            }&#x200b;</span>
 384:        : <span class="white">//            var timespan = stopwatch.Elapsed;&#x200b;</span>
 385:        : <span class="white">//            Console.WriteLine("Test suite benchmarked at {0:0.000} seconds.", timespan.TotalSeconds);&#x200b;</span>
 386:        : <span class="white">//&#x200b;</span>
 387:        : <span class="white">//            return timespan;&#x200b;</span>
 388:        : <span class="white">//        }&#x200b;</span>
 389:        : <span class="white">&#x200b;</span>
 390:        : <span class="white">        private Process GetTestRunnerProcess(TestDirectory testDirectory)&#x200b;</span>
 391:        : <span class="white">        {&#x200b;</span>
 392:        : <span class="white">            if (_runner == null) _runner = (ITestRunner)Activator.CreateInstance(MutationTestBuilder.TestRunner);&#x200b;</span>
 393:        : <span class="white">            return _runner.GetRunnerProcess(testDirectory, _testAssemblyLocation, _testsToRun);&#x200b;</span>
 394:        : <span class="white">        }&#x200b;</span>
 395:        : <span class="white">&#x200b;</span>
 396:        : <span class="white">        private bool CheckTestProcessFails(MethodTurtleBase turtle, MutantMetaData mutation)&#x200b;</span>
 397:        : <span class="white">        {&#x200b;</span>
 398:     1/1: <span class="green">            var process = GetTestRunnerProcess(mutation.TestDirectory);&#x200b;</span>
 399:        : <span class="white">&#x200b;</span>
 400:     1/1: <span class="green">            process.Start();&#x200b;</span>
 401:     4/4: <span class="green">            bool exitedInTime = process.WaitForExit(30000); //Math.Min(30000, (int)(5 * _benchmark.TotalMilliseconds)));&#x200b;</span>
 402:     1/1: <span class="green">            int exitCode = -1;&#x200b;</span>
 403:        : <span class="white">&#x200b;</span>
 404:        : <span class="white">            try&#x200b;</span>
 405:        : <span class="white">            {&#x200b;</span>
 406:   14/14: <span class="green">                if (!exitedInTime)&#x200b;</span>
 407:        : <span class="white">                {&#x200b;</span>
 408:     1/1: <span class="green">                    KillProcessAndChildren(process.Id);&#x200b;</span>
 409:        : <span class="white">                }&#x200b;</span>
 410:     1/1: <span class="green">                exitCode = process.ExitCode;&#x200b;</span>
 411:     1/1: <span class="green">            }&#x200b;</span>
 412:     2/2: <span class="green">            catch {}&#x200b;</span>
 413:        : <span class="white">&#x200b;</span>
 414:     7/7: <span class="green">            bool testSuitePassed = exitCode == 0 &amp;&amp; exitedInTime;&#x200b;</span>
 415:        : <span class="white">            &#x200b;</span>
 416:     7/7: <span class="green">            string result = string.Format("Mutant: {0}. {1}",&#x200b;</span>
 417:     7/7: <span class="green">                              mutation.Description,&#x200b;</span>
 418:     7/7: <span class="green">                              testSuitePassed&#x200b;</span>
 419:     7/7: <span class="green">                                  ? "Survived."&#x200b;</span>
 420:     7/7: <span class="green">                                : "Killed.");&#x200b;</span>
 421:     4/4: <span class="green">            _report.AddResult(turtle.GetCurrentSequencePoint(mutation.ILIndex), mutation, !testSuitePassed);&#x200b;</span>
 422:        : <span class="white">&#x200b;</span>
 423:   14/14: <span class="green">            if (testSuitePassed)&#x200b;</span>
 424:        : <span class="white">            {&#x200b;</span>
 425:     1/1: <span class="green">                mutation.TestDirectory.DoNotDelete = true;&#x200b;</span>
 426:     1/1: <span class="green">                result = string.Format("{0}\nOriginal source code around surviving mutant (in {1}):\n{2}\nFiles left for inspection in: {3}",&#x200b;</span>
 427:     1/1: <span class="green">                    result,&#x200b;</span>
 428:     1/1: <span class="green">                    turtle.GetOriginalSourceFileName(mutation.ILIndex),&#x200b;</span>
 429:     1/1: <span class="green">                    turtle.GetOriginalSourceCode(mutation.ILIndex),&#x200b;</span>
 430:     1/1: <span class="green">                    mutation.TestDirectoryName);&#x200b;</span>
 431:        : <span class="white">            }&#x200b;</span>
 432:        : <span class="white">&#x200b;</span>
 433:     1/1: <span class="green">            Console.WriteLine(result);&#x200b;</span>
 434:        : <span class="white">&#x200b;</span>
 435:     1/1: <span class="green">            turtle.MutantComplete(mutation);&#x200b;</span>
 436:     6/6: <span class="green">            return !testSuitePassed;&#x200b;</span>
 437:        : <span class="amber">        }&#x200b;</span>
 438:        : <span class="white">&#x200b;</span>
 439:        : <span class="white">        private void KillProcessAndChildren(int pid)&#x200b;</span>
 440:        : <span class="white">        {&#x200b;</span>
 441:        : <span class="white">            using (var searcher = new ManagementObjectSearcher("Select * From Win32_Process Where ParentProcessID=" + pid))&#x200b;</span>
 442:        : <span class="white">            using (ManagementObjectCollection moc = searcher.Get())&#x200b;</span>
 443:        : <span class="white">            {&#x200b;</span>
 444:        : <span class="white">                foreach (ManagementObject mo in moc)&#x200b;</span>
 445:        : <span class="white">                {&#x200b;</span>
 446:        : <span class="white">                    KillProcessAndChildren(Convert.ToInt32(mo["ProcessID"]));&#x200b;</span>
 447:        : <span class="white">                }&#x200b;</span>
 448:        : <span class="white">                try&#x200b;</span>
 449:        : <span class="white">                {&#x200b;</span>
 450:        : <span class="white">                    Process proc = Process.GetProcessById(pid);&#x200b;</span>
 451:        : <span class="white">                    proc.Kill();&#x200b;</span>
 452:        : <span class="white">                }&#x200b;</span>
 453:        : <span class="white">                catch (ArgumentException) {}&#x200b;</span>
 454:        : <span class="white">            }&#x200b;</span>
 455:        : <span class="white">        }&#x200b;</span>
 456:        : <span class="white">&#x200b;</span>
 457:        : <span class="white">                &#x200b;</span>
 458:        : <span class="white">        private void PopulateDefaultTurtles()&#x200b;</span>
 459:        : <span class="white">        {&#x200b;</span>
 460:        : <span class="white">            foreach (var type in GetType().Assembly.GetTypes()&#x200b;</span>
 461:        : <span class="white">                .Where(t =&gt; t.GetInterface("IMethodTurtle") != null&#x200b;</span>
 462:        : <span class="white">                &amp;&amp; !t.IsAbstract))&#x200b;</span>
 463:        : <span class="white">            {&#x200b;</span>
 464:        : <span class="white">                _mutationsToApply.Add(type);&#x200b;</span>
 465:        : <span class="white">            }&#x200b;</span>
 466:        : <span class="white">        }&#x200b;</span>
 467:        : <span class="white">&#x200b;</span>
 468:        : <span class="white">        private MethodDefinition ValidateMethod()&#x200b;</span>
 469:        : <span class="white">        {&#x200b;</span>
 470:        : <span class="white">            _module = new Module(TargetType.Assembly.Location);&#x200b;</span>
 471:        : <span class="white">&#x200b;</span>
 472:        : <span class="white">            var type = ResolveFromTypeCollection(_module.Definition.Types);&#x200b;</span>
 473:        : <span class="white">            return MethodDefinitionResolver.ResolveMethod(type, TargetMethod, _parameterTypes);&#x200b;</span>
 474:        : <span class="white">        }&#x200b;</span>
 475:        : <span class="white">&#x200b;</span>
 476:        : <span class="white">        private TypeDefinition ResolveFromTypeCollection(Collection&lt;TypeDefinition&gt; types)&#x200b;</span>
 477:        : <span class="white">        {&#x200b;</span>
 478:        : <span class="white">            var type = types.SingleOrDefault(t =&gt; t.FullName == TargetType.FullName.Replace("+", "/"));&#x200b;</span>
 479:        : <span class="white">            if (type == null)&#x200b;</span>
 480:        : <span class="white">            {&#x200b;</span>
 481:        : <span class="white">                foreach (var typeDefinition in types)&#x200b;</span>
 482:        : <span class="white">                {&#x200b;</span>
 483:        : <span class="white">                    if (typeDefinition.NestedTypes != null)&#x200b;</span>
 484:        : <span class="white">                    {&#x200b;</span>
 485:        : <span class="white">                        type = ResolveFromTypeCollection(typeDefinition.NestedTypes);&#x200b;</span>
 486:        : <span class="white">                        if (type != null) return type;&#x200b;</span>
 487:        : <span class="white">                    }&#x200b;</span>
 488:        : <span class="white">                }&#x200b;</span>
 489:        : <span class="white">            }&#x200b;</span>
 490:        : <span class="white">            return type;&#x200b;</span>
 491:        : <span class="white">        }&#x200b;</span>
 492:        : <span class="white">&#x200b;</span>
 493:        : <span class="white">        public IMutationTest With&lt;T&gt;() where T : IMethodTurtle&#x200b;</span>
 494:        : <span class="white">        {&#x200b;</span>
 495:        : <span class="white">            _mutationsToApply.Add(typeof(T));&#x200b;</span>
 496:        : <span class="white">            return this;&#x200b;</span>
 497:        : <span class="white">        }&#x200b;</span>
 498:        : <span class="white">&#x200b;</span>
 499:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 500:        : <span class="white">        /// Sets the unit test runner to be used, which is an implementation of&#x200b;</span>
 501:        : <span class="white">        /// &lt;see cref="ITestRunner" /&gt;. If none is specified, then the default&#x200b;</span>
 502:        : <span class="white">        /// is to use &lt;see cref="NUnitTestRunner" /&gt;.&#x200b;</span>
 503:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 504:        : <span class="white">        /// &lt;typeparam name="T"&gt;&#x200b;</span>
 505:        : <span class="white">        /// A type that implements &lt;see cref="ITestRunner" /&gt;.&#x200b;</span>
 506:        : <span class="white">        /// &lt;/typeparam&gt;&#x200b;</span>
 507:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
 508:        : <span class="white">        /// The original &lt;see cref="IMutationTest" /&gt; instance to allow fluent&#x200b;</span>
 509:        : <span class="white">        /// method chaining.&#x200b;</span>
 510:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
 511:        : <span class="white">        public IMutationTest UsingRunner&lt;T&gt;() where T : ITestRunner, new()&#x200b;</span>
 512:        : <span class="white">        {&#x200b;</span>
 513:        : <span class="white">            _runner = new T();&#x200b;</span>
 514:        : <span class="white">            return this;&#x200b;</span>
 515:        : <span class="white">        }&#x200b;</span>
 516:        : <span class="white">&#x200b;</span>
 517:        : <span class="white">        public IMutationTest WriteReportTo(string fileName)&#x200b;</span>
 518:        : <span class="white">        {&#x200b;</span>
 519:        : <span class="white">            _reportingStrategy = new OverwriteReportingStrategy();&#x200b;</span>
 520:        : <span class="white">            _reportFileName = fileName;&#x200b;</span>
 521:        : <span class="white">            return this;&#x200b;</span>
 522:        : <span class="white">        }&#x200b;</span>
 523:        : <span class="white">&#x200b;</span>
 524:        : <span class="white">        public IMutationTest MergeReportTo(string fileName)&#x200b;</span>
 525:        : <span class="white">        {&#x200b;</span>
 526:        : <span class="white">            _reportingStrategy = new MergeReportingStrategy();&#x200b;</span>
 527:        : <span class="white">            _reportFileName = fileName;&#x200b;</span>
 528:        : <span class="white">            return this;&#x200b;</span>
 529:        : <span class="white">        }&#x200b;</span>
 530:        : <span class="white">&#x200b;</span>
 531:        : <span class="white">        private abstract class ReportingStrategy&#x200b;</span>
 532:        : <span class="white">        {&#x200b;</span>
 533:        : <span class="white">            public abstract void WriteReport(MutationTestingReport report, string fileName);&#x200b;</span>
 534:        : <span class="white">        }&#x200b;</span>
 535:        : <span class="white">&#x200b;</span>
 536:        : <span class="white">        private class NullReportingStrategy : ReportingStrategy&#x200b;</span>
 537:        : <span class="white">        {&#x200b;</span>
 538:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName) { }&#x200b;</span>
 539:        : <span class="white">        }&#x200b;</span>
 540:        : <span class="white">&#x200b;</span>
 541:        : <span class="white">        private class OverwriteReportingStrategy : ReportingStrategy&#x200b;</span>
 542:        : <span class="white">        {&#x200b;</span>
 543:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName)&#x200b;</span>
 544:        : <span class="white">            {&#x200b;</span>
 545:        : <span class="white">                using (var streamWriter = File.CreateText(fileName))&#x200b;</span>
 546:        : <span class="white">                {&#x200b;</span>
 547:        : <span class="white">                    new XmlSerializer(typeof(MutationTestingReport)).Serialize(streamWriter, report);&#x200b;</span>
 548:        : <span class="white">                }&#x200b;</span>
 549:        : <span class="white">            }&#x200b;</span>
 550:        : <span class="white">        }&#x200b;</span>
 551:        : <span class="white">&#x200b;</span>
 552:        : <span class="white">        private class MergeReportingStrategy : ReportingStrategy&#x200b;</span>
 553:        : <span class="white">        {&#x200b;</span>
 554:        : <span class="white">            public override void WriteReport(MutationTestingReport report, string fileName)&#x200b;</span>
 555:        : <span class="white">            {&#x200b;</span>
 556:        : <span class="white">                report.MergeFromFile(fileName);&#x200b;</span>
 557:        : <span class="white">                using (var streamWriter = File.CreateText(fileName))&#x200b;</span>
 558:        : <span class="white">                {&#x200b;</span>
 559:        : <span class="white">                    new XmlSerializer(typeof(MutationTestingReport)).Serialize(streamWriter, report);&#x200b;</span>
 560:        : <span class="white">                }&#x200b;</span>
 561:        : <span class="white">            }&#x200b;</span>
 562:        : <span class="white">        }&#x200b;</span>
 563:        : <span class="white">    }&#x200b;</span>
 564:        : <span class="white">}&#x200b;</span>
 565:        : <span class="white">&#x200b;</span>
</pre><h1>MutationTestBuilder.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Reflection;&#x200b;</span>
  24:        : <span class="white">&#x200b;</span>
  25:        : <span class="white">using NinjaTurtles.TestRunners;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  28:        : <span class="white">{&#x200b;</span>
  29:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  30:        : <span class="white">    /// A static class used as the starting point for a fluent definition of&#x200b;</span>
  31:        : <span class="white">    /// a set of mutation tests.&#x200b;</span>
  32:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  33:        : <span class="white">    /// &lt;typeparam name="T"&gt;&#x200b;</span>
  34:        : <span class="white">    /// The type to be tested.&#x200b;</span>
  35:        : <span class="white">    /// &lt;/typeparam&gt;&#x200b;</span>
  36:        : <span class="white">    /// &lt;example&gt;&#x200b;</span>
  37:        : <span class="white">    /// &lt;para&gt;&#x200b;</span>
  38:        : <span class="white">    /// This code creates and runs mutation tests for the &#x200b;</span>
  39:        : <span class="white">    /// &lt;b&gt;ClassUnderTest&lt;/b&gt; class's &lt;b&gt;MethodUnderTest&lt;/b&gt; method:&#x200b;</span>
  40:        : <span class="white">    /// &lt;/para&gt;&#x200b;</span>
  41:        : <span class="white">    /// &lt;code lang="cs"&gt;&#x200b;</span>
  42:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest&amp;gt;&#x200b;</span>
  43:        : <span class="white">    ///     .For("MethodUnderTest")&#x200b;</span>
  44:        : <span class="white">    ///     .Run();&#x200b;</span>
  45:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  46:        : <span class="white">    /// &lt;code lang="vbnet"&gt;&#x200b;</span>
  47:        : <span class="white">    /// Call MutationTestBuilder(Of ClassUnderTest) _&#x200b;</span>
  48:        : <span class="white">    ///     .For("MethodUnderTest") _&#x200b;</span>
  49:        : <span class="white">    ///     .Run&#x200b;</span>
  50:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  51:        : <span class="white">    /// &lt;code lang="cpp"&gt;&#x200b;</span>
  52:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest^&amp;gt;&#x200b;</span>
  53:        : <span class="white">    ///     ::For("MethodUnderTest")&#x200b;</span>
  54:        : <span class="white">    ///     -&gt;Run();&#x200b;</span>
  55:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  56:        : <span class="white">    /// &lt;para&gt;&#x200b;</span>
  57:        : <span class="white">    /// When this code is included in a test, it causes the matching tests to&#x200b;</span>
  58:        : <span class="white">    /// be run for each mutation that is found of the code under test. The&#x200b;</span>
  59:        : <span class="white">    /// matching tests are determined automatically by NinjaTurtles. By&#x200b;</span>
  60:        : <span class="white">    /// default, NinjaTurtles assumes it is running under NUnit, and thus uses&#x200b;</span>
  61:        : <span class="white">    /// an NUnit runner to run the suite against the mutated code. This can be&#x200b;</span>
  62:        : <span class="white">    /// changed using the fluent interface:&#x200b;</span>
  63:        : <span class="white">    /// &lt;/para&gt;&#x200b;</span>
  64:        : <span class="white">    /// &lt;code lang="cs"&gt;&#x200b;</span>
  65:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest&amp;gt;&#x200b;</span>
  66:        : <span class="white">    ///     .For("MethodUnderTest")&#x200b;</span>
  67:        : <span class="white">    ///     .UsingRunner&amp;lt;GallioTestRunner&amp;gt;()&#x200b;</span>
  68:        : <span class="white">    ///     .Run();&#x200b;</span>
  69:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  70:        : <span class="white">    /// &lt;code lang="vbnet"&gt;&#x200b;</span>
  71:        : <span class="white">    /// Call MutationTestBuilder(Of ClassUnderTest) _&#x200b;</span>
  72:        : <span class="white">    ///     .For("MethodUnderTest") _&#x200b;</span>
  73:        : <span class="white">    ///     .UsingRunner(Of GallioTestRunner)() _&#x200b;</span>
  74:        : <span class="white">    ///     .Run&#x200b;</span>
  75:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  76:        : <span class="white">    /// &lt;code lang="cpp"&gt;&#x200b;</span>
  77:        : <span class="white">    /// MutationTestBuilder&amp;lt;ClassUnderTest^&amp;gt;&#x200b;</span>
  78:        : <span class="white">    ///     ::For("MethodUnderTest")&#x200b;</span>
  79:        : <span class="white">    ///     -&gt;UsingRunner&amp;lt;GallioTestRunner^&amp;gt;()&#x200b;</span>
  80:        : <span class="white">    ///     -&gt;Run();&#x200b;</span>
  81:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  82:        : <span class="white">    /// &lt;para&gt;&#x200b;</span>
  83:        : <span class="white">    /// Alternatively, this option can be set across all tests in a fixture by&#x200b;</span>
  84:        : <span class="white">    /// including this line in the test fixture's setup method:&#x200b;</span>
  85:        : <span class="white">    /// &lt;/para&gt;&#x200b;</span>
  86:        : <span class="white">    /// &lt;code lang="cs"&gt;&#x200b;</span>
  87:        : <span class="white">    /// MutationTestBuilder.UseRunner&amp;lt;GallioTestRunner&amp;gt;();&#x200b;</span>
  88:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  89:        : <span class="white">    /// &lt;code lang="vbnet"&gt;&#x200b;</span>
  90:        : <span class="white">    /// Call MutationTestBuilder.UseRunner(Of GallioTestRunner)&#x200b;</span>
  91:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  92:        : <span class="white">    /// &lt;code lang="cpp"&gt;&#x200b;</span>
  93:        : <span class="white">    /// MutationTestBuilder::UseRunner&amp;lt;GallioTestRunner^&amp;gt;();&#x200b;</span>
  94:        : <span class="white">    /// &lt;/code&gt;&#x200b;</span>
  95:        : <span class="white">    /// &lt;/example&gt;&#x200b;</span>
  96:        : <span class="white">    public sealed class MutationTestBuilder&lt;T&gt;&#x200b;</span>
  97:        : <span class="white">    {&#x200b;</span>
  98:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  99:        : <span class="white">        /// Returns an &lt;see cref="IMutationTest" /&gt; instance allowing a fluent&#x200b;</span>
 100:        : <span class="white">        /// definition of a set of mutation tests for a particular method.&#x200b;</span>
 101:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 102:        : <span class="white">        /// &lt;param name="targetMethod"&gt;&#x200b;</span>
 103:        : <span class="white">        /// The name of the method to mutate.&#x200b;</span>
 104:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 105:        : <span class="white">        /// &lt;param name="parameterTypes"&gt;&#x200b;</span>
 106:        : <span class="white">        /// Optional parameter specifying an array of parameter types used to&#x200b;</span>
 107:        : <span class="white">        /// identify a particular method overload.&#x200b;</span>
 108:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 109:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
 110:        : <span class="white">        /// An &lt;see cref="IMutationTest" /&gt; instance to allow fluent&#x200b;</span>
 111:        : <span class="white">        /// method chaining.&#x200b;</span>
 112:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
 113:        : <span class="white">        public static IMutationTest For(string targetMethod, Type[] parameterTypes = null)&#x200b;</span>
 114:        : <span class="white">        {&#x200b;</span>
 115:        : <span class="white">            var callingAssembly = Assembly.GetCallingAssembly();&#x200b;</span>
 116:        : <span class="white">            return MutationTestBuilder.For(callingAssembly.Location, typeof(T), targetMethod, parameterTypes);&#x200b;</span>
 117:        : <span class="white">        }&#x200b;</span>
 118:        : <span class="white">    }&#x200b;</span>
 119:        : <span class="white">&#x200b;</span>
 120:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
 121:        : <span class="white">    /// A static class used as the starting point for a fluent definition of&#x200b;</span>
 122:        : <span class="white">    /// a set of mutation tests.&#x200b;</span>
 123:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
 124:        : <span class="white">    /// &lt;remarks&gt;&#x200b;</span>
 125:        : <span class="white">    /// For public classes, the generic &lt;see cref="MutationTestBuilder{T}" /&gt;&#x200b;</span>
 126:        : <span class="white">    /// is to be prefered. See that class for full documentation.&#x200b;</span>
 127:        : <span class="white">    /// &lt;/remarks&gt;&#x200b;</span>
 128:        : <span class="white">    public sealed class MutationTestBuilder&#x200b;</span>
 129:        : <span class="white">    {&#x200b;</span>
 130:        : <span class="white">        internal static Type TestRunner { get; set; }&#x200b;</span>
 131:        : <span class="white">&#x200b;</span>
 132:        : <span class="white">        static MutationTestBuilder()&#x200b;</span>
 133:        : <span class="white">        {&#x200b;</span>
 134:        : <span class="white">            TestRunner = typeof(NUnitTestRunner);&#x200b;</span>
 135:        : <span class="white">        }&#x200b;</span>
 136:        : <span class="white">&#x200b;</span>
 137:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 138:        : <span class="white">        /// Returns an &lt;see cref="IMutationTest" /&gt; instance allowing a fluent&#x200b;</span>
 139:        : <span class="white">        /// definition of a set of mutation tests for a particular method.&#x200b;</span>
 140:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 141:        : <span class="white">        /// &lt;param name="targetClass"&gt;&#x200b;</span>
 142:        : <span class="white">        /// The namespace-qualified name of the type for which mutation tests&#x200b;</span>
 143:        : <span class="white">        /// are being defined.&#x200b;</span>
 144:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 145:        : <span class="white">        /// &lt;param name="targetMethod"&gt;&#x200b;</span>
 146:        : <span class="white">        /// The name of the method to mutate.&#x200b;</span>
 147:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 148:        : <span class="white">        /// &lt;param name="parameterTypes"&gt;&#x200b;</span>
 149:        : <span class="white">        /// Optional parameter specifying an array of parameter types used to&#x200b;</span>
 150:        : <span class="white">        /// identify a particular method overload.&#x200b;</span>
 151:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
 152:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
 153:        : <span class="white">        /// An &lt;see cref="IMutationTest" /&gt; instance to allow fluent&#x200b;</span>
 154:        : <span class="white">        /// method chaining.&#x200b;</span>
 155:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
 156:        : <span class="white">        public static IMutationTest For(string targetClass, string targetMethod, Type[] parameterTypes = null)&#x200b;</span>
 157:        : <span class="white">        {&#x200b;</span>
 158:     1/1: <span class="green">            var callingAssembly = Assembly.GetCallingAssembly();&#x200b;</span>
 159:     2/2: <span class="green">            Type resolvedType = TypeResolver.ResolveTypeFromReferences(callingAssembly, targetClass);&#x200b;</span>
 160:        : <span class="white">&#x200b;</span>
 161:     1/1: <span class="green">            return For(callingAssembly.Location, resolvedType, targetMethod, parameterTypes);&#x200b;</span>
 162:        : <span class="amber">        }&#x200b;</span>
 163:        : <span class="white">&#x200b;</span>
 164:        : <span class="white">        internal static IMutationTest For(string callingAssemblyLocation, Type targetType, string targetMethod, Type[] parameterTypes)&#x200b;</span>
 165:        : <span class="white">        {&#x200b;</span>
 166:        : <span class="white">            return new MutationTest(callingAssemblyLocation, targetType, targetMethod, parameterTypes);&#x200b;</span>
 167:        : <span class="white">        }&#x200b;</span>
 168:        : <span class="white">&#x200b;</span>
 169:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 170:        : <span class="white">        /// Specifies the implementation of &lt;see cref="ITestRunner" /&gt; to be&#x200b;</span>
 171:        : <span class="white">        /// used to run the test suite for each mutant. By default, this will&#x200b;</span>
 172:        : <span class="white">        /// be the &lt;see cref="NUnitTestRunner" /&gt;. This can still be overridden&#x200b;</span>
 173:        : <span class="white">        /// on a per-test basis using the&#x200b;</span>
 174:        : <span class="white">        /// &lt;see mref="IMutationTest.UsingRunner" /&gt; method.&#x200b;</span>
 175:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 176:        : <span class="white">        /// &lt;typeparam name="T"&gt;&#x200b;</span>
 177:        : <span class="white">        /// A type that implements &lt;see cref="ITestRunner" /&gt;.&#x200b;</span>
 178:        : <span class="white">        /// &lt;/typeparam&gt;&#x200b;</span>
 179:        : <span class="white">        public static void UseRunner&lt;T&gt;() where T : ITestRunner&#x200b;</span>
 180:        : <span class="white">        {&#x200b;</span>
 181:        : <span class="white">            TestRunner = typeof(T);&#x200b;</span>
 182:        : <span class="white">        }&#x200b;</span>
 183:        : <span class="white">    }&#x200b;</span>
 184:        : <span class="white">}&#x200b;</span>
 185:        : <span class="white">&#x200b;</span>
</pre><h1>OpCodeRotationTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">&#x200b;</span>
  24:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  25:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  28:        : <span class="white">{&#x200b;</span>
  29:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  30:        : <span class="white">    /// An abstract base class for implementations of&#x200b;</span>
  31:        : <span class="white">    /// &lt;see cref="IMethodTurtle" /&gt; that operator by replacing a number of&#x200b;</span>
  32:        : <span class="white">    /// IL OpCodes with a list of replacements in turn.&#x200b;</span>
  33:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  34:        : <span class="white">    /// &lt;remarks&gt;&#x200b;</span>
  35:        : <span class="white">    /// Classes extending this one only need to set the value of the&#x200b;</span>
  36:        : <span class="white">    /// &lt;see fref="_opCodes" /&gt; field to an appropriate dictionary of source&#x200b;</span>
  37:        : <span class="white">    /// and target OpCodes.&#x200b;</span>
  38:        : <span class="white">    /// &lt;/remarks&gt;&#x200b;</span>
  39:        : <span class="white">    public abstract class OpCodeRotationTurtle : MethodTurtleBase&#x200b;</span>
  40:        : <span class="white">    {&#x200b;</span>
  41:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  42:        : <span class="white">        /// An &lt;see cref="IDictionary{K,V}" /&gt; containing source OpCodes as&#x200b;</span>
  43:        : <span class="white">        /// keys, and &lt;see cref="IEnumerable{T}" /&gt;s of OpCodes as each key's&#x200b;</span>
  44:        : <span class="white">        /// possible replacements.&#x200b;</span>
  45:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  46:        : <span class="white">        protected IDictionary&lt;OpCode, IEnumerable&lt;OpCode&gt;&gt; _opCodes;&#x200b;</span>
  47:        : <span class="white">&#x200b;</span>
  48:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  49:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
  50:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
  51:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  52:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
  53:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
  54:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
  55:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
  56:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  57:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  58:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  59:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  60:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  61:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  62:        : <span class="white">        /// containing assembly.&#x200b;</span>
  63:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  64:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  65:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  66:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  67:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  68:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)&#x200b;</span>
  69:        : <span class="white">        {&#x200b;</span>
  70:   16/16: <span class="green">            for (int index = 0; index &lt; method.Body.Instructions.Count; index++)&#x200b;</span>
  71:        : <span class="white">            {&#x200b;</span>
  72:     2/2: <span class="green">                var instruction = method.Body.Instructions[index];&#x200b;</span>
  73:     7/7: <span class="green">                if (_opCodes.ContainsKey(instruction.OpCode))&#x200b;</span>
  74:        : <span class="white">                {&#x200b;</span>
  75:     8/8: <span class="green">                    if (instruction.IsMeaninglessUnconditionalBranch()) continue;&#x200b;</span>
  76:        : <span class="white">&#x200b;</span>
  77:     2/2: <span class="green">                    var originalOpCode = instruction.OpCode;&#x200b;</span>
  78:        : <span class="white">&#x200b;</span>
  79:   12/12: <span class="green">                    foreach (var opCode in _opCodes[originalOpCode])&#x200b;</span>
  80:        : <span class="white">                    {&#x200b;</span>
  81:     2/2: <span class="green">                        instruction.OpCode = opCode;&#x200b;</span>
  82:     5/5: <span class="green">                        var description = string.Format("{0:x4}: {1} =&gt; {2}", GetOriginalOffset(index), originalOpCode.Code, opCode.Code);&#x200b;</span>
  83:     2/2: <span class="green">                        MutantMetaData mutation = DoYield(method, module, description, index);&#x200b;</span>
  84:     4/4: <span class="green">                        yield return mutation;&#x200b;</span>
  85:        : <span class="white">                    }&#x200b;</span>
  86:        : <span class="white">&#x200b;</span>
  87:     2/2: <span class="green">                    instruction.OpCode = originalOpCode;&#x200b;</span>
  88:        : <span class="white">                }&#x200b;</span>
  89:        : <span class="white">            }&#x200b;</span>
  90:        : <span class="white">        }&#x200b;</span>
  91:        : <span class="white">    }&#x200b;</span>
  92:        : <span class="white">}&#x200b;</span>
</pre><h1>SequencePointDeletionTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  23:        : <span class="white">using System.Linq;&#x200b;</span>
  24:        : <span class="white">&#x200b;</span>
  25:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  26:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  27:        : <span class="white">&#x200b;</span>
  28:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  29:        : <span class="white">{&#x200b;</span>
  30:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  31:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that removes from the&#x200b;</span>
  32:        : <span class="white">    /// compiled IL each sequence point in turn (with the exception of&#x200b;</span>
  33:        : <span class="white">    /// structurally vital ones and compiler generated ones).&#x200b;</span>
  34:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  35:        : <span class="white">    public class SequencePointDeletionTurtle : MethodTurtleBase&#x200b;</span>
  36:        : <span class="white">    {&#x200b;</span>
  37:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  38:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
  39:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
  40:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  41:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
  42:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
  43:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
  44:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
  45:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  46:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  47:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  48:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  49:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  50:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  51:        : <span class="white">        /// containing assembly.&#x200b;</span>
  52:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  53:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  54:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  55:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  56:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  57:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)&#x200b;</span>
  58:        : <span class="white">        {&#x200b;</span>
  59:     1/1: <span class="green">            var sequence = new Dictionary&lt;int, OpCode&gt;();&#x200b;</span>
  60:     3/3: <span class="green">            int startIndex = -1;&#x200b;</span>
  61:   19/19: <span class="green">            for (int index = 0; index &lt; method.Body.Instructions.Count; index++)&#x200b;</span>
  62:        : <span class="white">            {&#x200b;</span>
  63:     3/3: <span class="green">                var instruction = method.Body.Instructions[index];&#x200b;</span>
  64:   10/10: <span class="green">                if (instruction.SequencePoint != null&#x200b;</span>
  65:   10/10: <span class="green">                    &amp;&amp; instruction.SequencePoint.StartLine != 0xfeefee)&#x200b;</span>
  66:        : <span class="white">                {&#x200b;</span>
  67:     5/5: <span class="green">                    startIndex = index;&#x200b;</span>
  68:     1/1: <span class="green">                    sequence.Clear();&#x200b;</span>
  69:        : <span class="white">                }&#x200b;</span>
  70:   10/10: <span class="green">                if (startIndex &gt;= 0)&#x200b;</span>
  71:        : <span class="white">                {&#x200b;</span>
  72:     3/3: <span class="green">                    sequence.Add(index, instruction.OpCode);&#x200b;</span>
  73:        : <span class="white">                }&#x200b;</span>
  74:   12/12: <span class="green">                if (index == method.Body.Instructions.Count - 1 || instruction.Next.SequencePoint != null)&#x200b;</span>
  75:        : <span class="white">                {&#x200b;</span>
  76:     8/8: <span class="green">                    if (!ShouldDeleteSequence(method.Body, sequence)) continue;&#x200b;</span>
  77:        : <span class="white">&#x200b;</span>
  78:     3/3: <span class="green">                    OpCode originalOpCode = method.Body.Instructions[startIndex].OpCode;&#x200b;</span>
  79:     3/3: <span class="green">                    object originalOperand = method.Body.Instructions[startIndex].Operand;&#x200b;</span>
  80:     3/3: <span class="green">                    method.Body.Instructions[startIndex].OpCode = OpCodes.Br;&#x200b;</span>
  81:     3/3: <span class="green">                    method.Body.Instructions[startIndex].Operand = instruction.Next;&#x200b;</span>
  82:        : <span class="white">&#x200b;</span>
  83:     5/5: <span class="green">                    var codes = string.Join(", ", sequence.Values.Select(o =&gt; o.Code));&#x200b;</span>
  84:     5/5: <span class="green">                    var description = string.Format("{0:x4}: deleting {1}", GetOriginalOffset(startIndex), codes);&#x200b;</span>
  85:     4/4: <span class="green">                    MutantMetaData mutation = DoYield(method, module, description, startIndex);&#x200b;</span>
  86:     4/4: <span class="green">                    yield return mutation;&#x200b;</span>
  87:        : <span class="white">&#x200b;</span>
  88:     3/3: <span class="green">                    method.Body.Instructions[startIndex].OpCode = originalOpCode;&#x200b;</span>
  89:     3/3: <span class="green">                    method.Body.Instructions[startIndex].Operand = originalOperand;&#x200b;</span>
  90:        : <span class="white">                }&#x200b;</span>
  91:        : <span class="white">            }&#x200b;</span>
  92:        : <span class="white">        }&#x200b;</span>
  93:        : <span class="white">&#x200b;</span>
  94:        : <span class="white">        private bool ShouldDeleteSequence(MethodBody method, IDictionary&lt;int, OpCode&gt; opCodes)&#x200b;</span>
  95:        : <span class="white">        {&#x200b;</span>
  96:   11/11: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Nop)) return false;&#x200b;</span>
  97:   11/11: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Pop)) return false;&#x200b;</span>
  98:   11/11: <span class="green">            if (opCodes.Values.All(o =&gt; o == OpCodes.Leave)) return false;&#x200b;</span>
  99:   11/11: <span class="green">            if (opCodes.Values.Any(o =&gt; o == OpCodes.Ret)) return false;&#x200b;</span>
 100:        : <span class="white">&#x200b;</span>
 101:        : <span class="white">            // If just setting compiler-generated return variable in Debug mode, don't delete.&#x200b;</span>
 102:     7/7: <span class="green">            if (opCodes.Values.Last().Code == Code.Br)&#x200b;</span>
 103:        : <span class="white">            {&#x200b;</span>
 104:   11/11: <span class="green">                if (((Instruction)method.Instructions[opCodes.Keys.Last()].Operand).Offset&#x200b;</span>
 105:   11/11: <span class="green">                    == method.Instructions[opCodes.Keys.Last() + 1].Offset)&#x200b;</span>
 106:        : <span class="white">                {&#x200b;</span>
 107:   11/11: <span class="green">                    if (method.Instructions[opCodes.Keys.Last() + 2].OpCode == OpCodes.Ret)&#x200b;</span>
 108:        : <span class="white">                    {&#x200b;</span>
 109:     1/1: <span class="green">                        return false;&#x200b;</span>
 110:        : <span class="white">                    }&#x200b;</span>
 111:        : <span class="white">                }&#x200b;</span>
 112:        : <span class="white">            }&#x200b;</span>
 113:        : <span class="white">&#x200b;</span>
 114:        : <span class="white">            // If calling base constructor, don't delete.&#x200b;</span>
 115:   10/10: <span class="green">            if (opCodes.Any(kv =&gt; kv.Value == OpCodes.Call))&#x200b;</span>
 116:        : <span class="white">            {&#x200b;</span>
 117:   10/10: <span class="green">                if (((MethodReference)method.Instructions[opCodes.First(kv =&gt; kv.Value == OpCodes.Call).Key].Operand).Name == Methods.CONSTRUCTOR)&#x200b;</span>
 118:        : <span class="white">                {&#x200b;</span>
 119:     1/1: <span class="green">                    return false;&#x200b;</span>
 120:        : <span class="white">                }&#x200b;</span>
 121:        : <span class="white">            }&#x200b;</span>
 122:        : <span class="white">&#x200b;</span>
 123:        : <span class="white">            // If compiler-generated dispose, don't delete.&#x200b;</span>
 124:     7/7: <span class="green">            if (method.Instructions[opCodes.Keys.First()].IsPartOfCompilerGeneratedDispose())&#x200b;</span>
 125:        : <span class="white">            {&#x200b;</span>
 126:     1/1: <span class="green">                return false;&#x200b;</span>
 127:        : <span class="white">            }&#x200b;</span>
 128:        : <span class="white">&#x200b;</span>
 129:        : <span class="white">            // If setting default value to a field, don't delete.&#x200b;</span>
 130:   14/14: <span class="green">            if (method.Instructions[opCodes.Keys.First()]&#x200b;</span>
 131:   14/14: <span class="green">                .FollowsSequence(OpCodes.Ldarg, OpCodes.Ldc_I4, OpCodes.Stfld)&#x200b;</span>
 132:   14/14: <span class="green">                &amp;&amp; (int)method.Instructions[opCodes.Keys.First() + 1].Operand == 0)&#x200b;</span>
 133:        : <span class="white">            {&#x200b;</span>
 134:     1/1: <span class="green">                return false;&#x200b;</span>
 135:        : <span class="white">            }&#x200b;</span>
 136:        : <span class="white">&#x200b;</span>
 137:     1/1: <span class="green">            return true;&#x200b;</span>
 138:        : <span class="amber">        }&#x200b;</span>
 139:        : <span class="white">    }&#x200b;</span>
 140:        : <span class="white">}&#x200b;</span>
</pre><h1>TestDirectory.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.IO;&#x200b;</span>
  24:        : <span class="white">&#x200b;</span>
  25:        : <span class="white">using NLog;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  28:        : <span class="white">{&#x200b;</span>
  29:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  30:        : <span class="white">    /// Represents a temporary directory used to contain a mutated assembly&#x200b;</span>
  31:        : <span class="white">    /// to be tested. The directory cleans up after itself when its&#x200b;</span>
  32:        : <span class="white">    /// &lt;see mref="Dispose" /&gt; method is called, unless its&#x200b;</span>
  33:        : <span class="white">    /// &lt;see pref="DoNotDelete" /&gt; property is set to &lt;b&gt;true&lt;/b&gt;.&#x200b;</span>
  34:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  35:        : <span class="white">    public class TestDirectory : IDisposable&#x200b;</span>
  36:        : <span class="white">    {&#x200b;</span>
  37:        : <span class="white">        #region Logging&#x200b;</span>
  38:        : <span class="white">&#x200b;</span>
  39:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();&#x200b;</span>
  40:        : <span class="white">&#x200b;</span>
  41:        : <span class="white">        #endregion&#x200b;</span>
  42:        : <span class="white">&#x200b;</span>
  43:        : <span class="white">        private readonly string _folder;&#x200b;</span>
  44:        : <span class="white">&#x200b;</span>
  45:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  46:        : <span class="white">        /// Initializes a new instance of the &lt;see cref="TestDirectory" /&gt;&#x200b;</span>
  47:        : <span class="white">        /// class.&#x200b;</span>
  48:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  49:        : <span class="white">        public TestDirectory()&#x200b;</span>
  50:        : <span class="white">        {&#x200b;</span>
  51:     1/1: <span class="green">            _folder = Path.Combine(Path.GetTempPath(),&#x200b;</span>
  52:     1/1: <span class="green">                                   "NinjaTurtles",&#x200b;</span>
  53:     1/1: <span class="green">                                   Guid.NewGuid().ToString("N"));&#x200b;</span>
  54:     1/1: <span class="green">            _log.Debug("Creating folder \"{0}\".", _folder);&#x200b;</span>
  55:     1/1: <span class="green">            Directory.CreateDirectory(_folder);&#x200b;</span>
  56:        : <span class="white">        }&#x200b;</span>
  57:        : <span class="white">&#x200b;</span>
  58:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  59:        : <span class="white">        /// Initializes a new instance of the &lt;see cref="TestDirectory" /&gt;&#x200b;</span>
  60:        : <span class="white">        /// class.&#x200b;</span>
  61:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  62:        : <span class="white">        /// &lt;param name="sourceFolder"&gt;&#x200b;</span>
  63:        : <span class="white">        /// The name of a folder whose contents should be recursively&#x200b;</span>
  64:        : <span class="white">        /// copied to the temporary folder.&#x200b;</span>
  65:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  66:        : <span class="white">        public TestDirectory(string sourceFolder)&#x200b;</span>
  67:        : <span class="white">            : this()&#x200b;</span>
  68:        : <span class="white">        {&#x200b;</span>
  69:     2/2: <span class="green">            _log.Debug("Copying contents from folder \"{0}\".", sourceFolder);&#x200b;</span>
  70:     3/3: <span class="green">            CopyDirectoryContents(sourceFolder, _folder);&#x200b;</span>
  71:        : <span class="white">        }&#x200b;</span>
  72:        : <span class="white">&#x200b;</span>
  73:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  74:        : <span class="white">        /// Saves an image of a mutated assembly into the root of the test&#x200b;</span>
  75:        : <span class="white">        /// directory.&#x200b;</span>
  76:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  77:        : <span class="white">        /// &lt;param name="module"&gt;&lt;/param&gt;&#x200b;</span>
  78:        : <span class="white">        public void SaveAssembly(Module module)&#x200b;</span>
  79:        : <span class="white">        {&#x200b;</span>
  80:     3/3: <span class="green">            string fileName = Path.GetFileName(module.AssemblyLocation);&#x200b;</span>
  81:     7/7: <span class="green">            string path = Path.Combine(_folder, fileName);&#x200b;</span>
  82:     5/5: <span class="green">            _log.Debug("Writing assembly \"{0}\" to \"{1}\".", fileName, _folder);&#x200b;</span>
  83:     3/3: <span class="green">            module.AssemblyDefinition.Write(path);&#x200b;</span>
  84:        : <span class="white">        }&#x200b;</span>
  85:        : <span class="white">&#x200b;</span>
  86:        : <span class="white">        private static void CopyDirectoryContents&#x200b;</span>
  87:        : <span class="white">            (string directory, string targetDirectory)&#x200b;</span>
  88:        : <span class="white">        {&#x200b;</span>
  89:   19/19: <span class="green">            foreach (var file in Directory.GetFiles(directory))&#x200b;</span>
  90:        : <span class="white">            {&#x200b;</span>
  91:   11/11: <span class="green">                string fileName = Path.GetFileName(file);&#x200b;</span>
  92:     7/7: <span class="green">                _log.Trace("Copying file \"{0}\".", fileName);&#x200b;</span>
  93:   17/17: <span class="green">                string target = Path.Combine(targetDirectory, fileName);&#x200b;</span>
  94:   13/13: <span class="green">                File.Copy(file, target);&#x200b;</span>
  95:     5/5: <span class="green">            }&#x200b;</span>
  96:   19/19: <span class="green">            foreach (var subDirectory in Directory.GetDirectories(directory))&#x200b;</span>
  97:        : <span class="white">            {&#x200b;</span>
  98:   11/11: <span class="green">                string subDirectoryName = Path.GetFileName(subDirectory);&#x200b;</span>
  99:     7/7: <span class="green">                _log.Trace("Creating subdirectory \"{0}\".", subDirectoryName);&#x200b;</span>
 100:   17/17: <span class="green">                string target = Path.Combine(targetDirectory, subDirectoryName);&#x200b;</span>
 101:     7/7: <span class="green">                Directory.CreateDirectory(target);&#x200b;</span>
 102:   13/13: <span class="green">                CopyDirectoryContents(subDirectory, target);&#x200b;</span>
 103:     5/5: <span class="green">            }&#x200b;</span>
 104:        : <span class="white">        }&#x200b;</span>
 105:        : <span class="white">&#x200b;</span>
 106:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 107:        : <span class="white">        /// Gets the full path of the test directory.&#x200b;</span>
 108:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 109:        : <span class="white">        public string FullName&#x200b;</span>
 110:        : <span class="white">        {&#x200b;</span>
 111:        : <span class="white">            get { return _folder; }&#x200b;</span>
 112:        : <span class="white">        }&#x200b;</span>
 113:        : <span class="white">&#x200b;</span>
 114:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 115:        : <span class="white">        /// Performs application-defined tasks associated with freeing,&#x200b;</span>
 116:        : <span class="white">        /// releasing, or resetting unmanaged resources.&#x200b;</span>
 117:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 118:        : <span class="white">        public void Dispose()&#x200b;</span>
 119:        : <span class="white">        {&#x200b;</span>
 120:     5/5: <span class="green">            if (DoNotDelete)&#x200b;</span>
 121:        : <span class="white">            {&#x200b;</span>
 122:     1/1: <span class="green">                return;&#x200b;</span>
 123:        : <span class="white">            }&#x200b;</span>
 124:        : <span class="white">            try&#x200b;</span>
 125:        : <span class="white">            {&#x200b;</span>
 126:     2/2: <span class="green">                _log.Debug("Deleting folder \"{0}\".", _folder);&#x200b;</span>
 127:     2/2: <span class="green">                Directory.Delete(_folder, true);&#x200b;</span>
 128:     1/1: <span class="green">            }&#x200b;</span>
 129:     1/1: <span class="green">            catch (Exception ex)&#x200b;</span>
 130:        : <span class="white">            {&#x200b;</span>
 131:     3/3: <span class="green">                string message = string.Format("Failed to delete folder \"{0}\".", _folder);&#x200b;</span>
 132:     2/2: <span class="green">                _log.ErrorException(message, ex);&#x200b;</span>
 133:     2/2: <span class="green">            }&#x200b;</span>
 134:        : <span class="white">        }&#x200b;</span>
 135:        : <span class="white">&#x200b;</span>
 136:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
 137:        : <span class="white">        /// Gets or sets a flag indicating whether or not the contents of the&#x200b;</span>
 138:        : <span class="white">        /// test directory should be allowed to remain on disk when the&#x200b;</span>
 139:        : <span class="white">        /// instance is disposed.&#x200b;</span>
 140:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
 141:        : <span class="white">        public bool DoNotDelete { get; set; }&#x200b;</span>
 142:        : <span class="white">    }&#x200b;</span>
 143:        : <span class="white">}&#x200b;</span>
 144:        : <span class="white">&#x200b;</span>
</pre><h1>TypeResolver.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Linq;&#x200b;</span>
  25:        : <span class="white">using System.Reflection;&#x200b;</span>
  26:        : <span class="white">&#x200b;</span>
  27:        : <span class="white">using NLog;&#x200b;</span>
  28:        : <span class="white">&#x200b;</span>
  29:        : <span class="white">namespace NinjaTurtles&#x200b;</span>
  30:        : <span class="white">{&#x200b;</span>
  31:        : <span class="white">    internal class TypeResolver&#x200b;</span>
  32:        : <span class="white">    {&#x200b;</span>
  33:        : <span class="white">        #region Logging&#x200b;</span>
  34:        : <span class="white">&#x200b;</span>
  35:        : <span class="white">        private static Logger _log = LogManager.GetCurrentClassLogger();&#x200b;</span>
  36:        : <span class="white">&#x200b;</span>
  37:        : <span class="white">        #endregion&#x200b;</span>
  38:        : <span class="white">&#x200b;</span>
  39:        : <span class="white">        internal static Type ResolveTypeFromReferences(Assembly callingAssembly, string className)&#x200b;</span>
  40:        : <span class="white">        {&#x200b;</span>
  41:     1/1: <span class="green">            _log.Debug("Resolving type \"{0}\" in \"{1}\".", className, callingAssembly.GetName().Name);&#x200b;</span>
  42:     2/2: <span class="green">            Type type = ResolveTypeFromReferences(callingAssembly, className, new List&lt;string&gt;());&#x200b;</span>
  43:     6/6: <span class="green">            if (type == null)&#x200b;</span>
  44:        : <span class="white">            {&#x200b;</span>
  45:     1/1: <span class="green">                _log.Error("Could not find type \"{0}\".", className);&#x200b;</span>
  46:        : <span class="white">            }&#x200b;</span>
  47:     2/2: <span class="green">            return type;&#x200b;</span>
  48:        : <span class="amber">        }&#x200b;</span>
  49:        : <span class="white">&#x200b;</span>
  50:        : <span class="white">        private static Type ResolveTypeFromReferences(Assembly assembly, string className, IList&lt;string&gt; consideredAssemblies)&#x200b;</span>
  51:        : <span class="white">        {&#x200b;</span>
  52:     2/2: <span class="green">            _log.Trace("Searching for type \"{0}\" in \"{1}\".", className, assembly.GetName().Name);&#x200b;</span>
  53:     3/3: <span class="green">            var type = assembly.GetTypes().SingleOrDefault(t =&gt; t.FullName == className);&#x200b;</span>
  54:     6/6: <span class="green">            if (type != null)&#x200b;</span>
  55:        : <span class="white">            {&#x200b;</span>
  56:     2/2: <span class="green">                _log.Trace("Found type \"{0}\" in \"{1}\".", className, assembly.GetName().Name);&#x200b;</span>
  57:     3/3: <span class="green">                return type;&#x200b;</span>
  58:        : <span class="white">            }&#x200b;</span>
  59:   10/10: <span class="green">            foreach (var reference in assembly.GetReferencedAssemblies())&#x200b;</span>
  60:        : <span class="white">            {&#x200b;</span>
  61:     6/6: <span class="green">                if (consideredAssemblies.Contains(reference.Name)) continue;&#x200b;</span>
  62:     1/1: <span class="green">                consideredAssemblies.Add(reference.Name);&#x200b;</span>
  63:     1/1: <span class="green">                Assembly referencedAssembly = Assembly.Load(reference);&#x200b;</span>
  64:     3/3: <span class="green">                type = ResolveTypeFromReferences(referencedAssembly, className, consideredAssemblies);&#x200b;</span>
  65:     6/6: <span class="green">                if (type != null)&#x200b;</span>
  66:        : <span class="white">                {&#x200b;</span>
  67:     3/3: <span class="green">                    return type;&#x200b;</span>
  68:        : <span class="white">                }&#x200b;</span>
  69:     5/5: <span class="green">            }&#x200b;</span>
  70:     3/3: <span class="green">            return null;&#x200b;</span>
  71:        : <span class="amber">        }&#x200b;</span>
  72:        : <span class="white">    }&#x200b;</span>
  73:        : <span class="white">}&#x200b;</span>
  74:        : <span class="white">&#x200b;</span>
</pre><h1>VariableReadTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Linq;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  28:        : <span class="white">&#x200b;</span>
  29:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  30:        : <span class="white">{&#x200b;</span>
  31:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  32:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that identifies local&#x200b;</span>
  33:        : <span class="white">    /// variables, method parameters and fields of the same type, and permutes&#x200b;</span>
  34:        : <span class="white">    /// any reads from them. For example, if two &lt;see cref="Int32" /&gt;&#x200b;</span>
  35:        : <span class="white">    /// parameters &lt;c&gt;a&lt;/c&gt; and &lt;c&gt;b&lt;/c&gt; exist, along with a local variable&#x200b;</span>
  36:        : <span class="white">    /// &lt;c&gt;c&lt;/c&gt; of the same type, then a read from &lt;c&gt;a&lt;/c&gt; will be replaced&#x200b;</span>
  37:        : <span class="white">    /// by one from &lt;c&gt;b&lt;/c&gt; and &lt;c&gt;c&lt;/c&gt; in turn, and so on.&#x200b;</span>
  38:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  39:        : <span class="white">    public class VariableReadTurtle : MethodTurtleBase&#x200b;</span>
  40:        : <span class="white">    {&#x200b;</span>
  41:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  42:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
  43:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
  44:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  45:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
  46:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
  47:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
  48:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
  49:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  50:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  51:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  52:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  53:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  54:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  55:        : <span class="white">        /// containing assembly.&#x200b;</span>
  56:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  57:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  58:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  59:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  60:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  61:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)&#x200b;</span>
  62:        : <span class="white">        {&#x200b;</span>
  63:     1/1: <span class="green">            var variablesByType = GroupVariablesByType(method);&#x200b;</span>
  64:     1/1: <span class="green">            PopulateOperandsInVariables(method, variablesByType);&#x200b;</span>
  65:        : <span class="white">&#x200b;</span>
  66:     7/7: <span class="green">            if (!variablesByType.Any(kv =&gt; variablesByType[kv.Key].Count &gt; 1))&#x200b;</span>
  67:        : <span class="white">            {&#x200b;</span>
  68:     1/1: <span class="green">                yield break;&#x200b;</span>
  69:        : <span class="white">            }&#x200b;</span>
  70:        : <span class="white">&#x200b;</span>
  71:   13/13: <span class="green">            foreach (var keyValuePair in variablesByType.Where(kv =&gt; kv.Value.Count &gt; 1))&#x200b;</span>
  72:        : <span class="white">            {&#x200b;</span>
  73:     1/1: <span class="green">                var variables = keyValuePair.Value.ToList();&#x200b;</span>
  74:   22/22: <span class="green">                for (int index = 0; index &lt; method.Body.Instructions.Count; index++)&#x200b;</span>
  75:        : <span class="white">                {&#x200b;</span>
  76:     4/4: <span class="green">                    var instruction = method.Body.Instructions[index];&#x200b;</span>
  77:   11/11: <span class="green">                    if (instruction.OpCode == OpCodes.Ldloc &amp;&amp; instruction.Next.OpCode == OpCodes.Ret) continue;&#x200b;</span>
  78:        : <span class="white">&#x200b;</span>
  79:     4/4: <span class="green">                    int oldIndex = -1;&#x200b;</span>
  80:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldarg)&#x200b;</span>
  81:        : <span class="white">                    {&#x200b;</span>
  82:     1/1: <span class="green">                        int parameterIndex = ((ParameterDefinition)instruction.Operand).Sequence;&#x200b;</span>
  83:     4/4: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Parameter &amp;&amp; v.Index == parameterIndex);&#x200b;</span>
  84:        : <span class="white">                    }&#x200b;</span>
  85:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldloc)&#x200b;</span>
  86:        : <span class="white">                    {&#x200b;</span>
  87:     1/1: <span class="green">                        int variableIndex = ((VariableDefinition)instruction.Operand).Index;&#x200b;</span>
  88:     4/4: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == variableIndex);&#x200b;</span>
  89:        : <span class="white">                    }&#x200b;</span>
  90:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Ldfld)&#x200b;</span>
  91:        : <span class="white">                    {&#x200b;</span>
  92:     1/1: <span class="green">                        string fieldName = ((FieldDefinition)instruction.Operand).Name;&#x200b;</span>
  93:     4/4: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == fieldName);&#x200b;</span>
  94:        : <span class="white">                    }&#x200b;</span>
  95:        : <span class="white">&#x200b;</span>
  96:   12/12: <span class="green">                    if (oldIndex &lt; 0) continue;&#x200b;</span>
  97:        : <span class="white">&#x200b;</span>
  98:     1/1: <span class="green">                    OpCode originalOpCode = instruction.OpCode;&#x200b;</span>
  99:     1/1: <span class="green">                    object originalOperand = instruction.Operand;&#x200b;</span>
 100:     5/5: <span class="green">                    var originalVariable = variables[oldIndex];&#x200b;</span>
 101:        : <span class="white">&#x200b;</span>
 102:   22/22: <span class="green">                    for (int newIndex = 0; newIndex &lt; variables.Count; newIndex++)&#x200b;</span>
 103:        : <span class="white">                    {&#x200b;</span>
 104:   14/14: <span class="green">                        if (newIndex == oldIndex) continue;&#x200b;</span>
 105:     5/5: <span class="green">                        var variable = variables[newIndex];&#x200b;</span>
 106:     9/9: <span class="green">                        if (variable.Operand == null) continue;&#x200b;</span>
 107:        : <span class="white">&#x200b;</span>
 108:   18/18: <span class="green">                        if (variable.Type == VariableType.Parameter&#x200b;</span>
 109:   18/18: <span class="green">                            &amp;&amp; instruction.OpCode == OpCodes.Ldloc&#x200b;</span>
 110:   18/18: <span class="green">                            &amp;&amp; instruction.Previous.OpCode == OpCodes.Stloc&#x200b;</span>
 111:   18/18: <span class="green">                            &amp;&amp; ((VariableDefinition)instruction.Operand).Index == ((VariableDefinition)instruction.Previous.Operand).Index&#x200b;</span>
 112:   18/18: <span class="green">                            &amp;&amp; instruction.Previous.Previous.OpCode == OpCodes.Ldarg&#x200b;</span>
 113:   18/18: <span class="green">                            &amp;&amp; ((ParameterDefinition)instruction.Previous.Previous.Operand).Index == variable.Index)&#x200b;</span>
 114:        : <span class="white">                        {&#x200b;</span>
 115:        : <span class="white">                            // The .NET compiler sometimes adds a pointless&#x200b;</span>
 116:        : <span class="white">                            // cache of a parameter into a local variable&#x200b;</span>
 117:        : <span class="white">                            // (oddly, Mono doesn't seem to). We need to not&#x200b;</span>
 118:        : <span class="white">                            // mutate in this scenario.&#x200b;</span>
 119:     1/1: <span class="green">                            continue;&#x200b;</span>
 120:        : <span class="white">                        }&#x200b;</span>
 121:        : <span class="white">&#x200b;</span>
 122:     7/7: <span class="green">                        if (instruction.IsPartOfCompilerGeneratedDispose())&#x200b;</span>
 123:        : <span class="white">                        {&#x200b;</span>
 124:     1/1: <span class="green">                            continue;&#x200b;</span>
 125:        : <span class="white">                        }&#x200b;</span>
 126:        : <span class="white">&#x200b;</span>
 127:     2/2: <span class="green">                        instruction.OpCode = variable.GetReadOpCode();&#x200b;</span>
 128:     2/2: <span class="green">                        instruction.Operand = variable.Operand;&#x200b;</span>
 129:        : <span class="white">&#x200b;</span>
 130:     6/6: <span class="green">                        var description =&#x200b;</span>
 131:     6/6: <span class="green">                            string.Format(&#x200b;</span>
 132:     6/6: <span class="green">                                "{0:x4}: read substitution {1}.{2} =&gt; {1}.{3}",&#x200b;</span>
 133:     6/6: <span class="green">                                GetOriginalOffset(index),&#x200b;</span>
 134:     6/6: <span class="green">                                keyValuePair.Key.Name,&#x200b;</span>
 135:     6/6: <span class="green">                                originalVariable.Name,&#x200b;</span>
 136:     6/6: <span class="green">                                variable.Name);&#x200b;</span>
 137:        : <span class="white">&#x200b;</span>
 138:     4/4: <span class="green">                        var mutantMetaData = DoYield(method, module, description, index);&#x200b;</span>
 139:     4/4: <span class="green">                        yield return mutantMetaData;&#x200b;</span>
 140:        : <span class="white">                    }&#x200b;</span>
 141:     1/1: <span class="green">                    instruction.OpCode = originalOpCode;&#x200b;</span>
 142:     1/1: <span class="green">                    instruction.Operand = originalOperand;&#x200b;</span>
 143:        : <span class="white">                }&#x200b;</span>
 144:        : <span class="white">            }&#x200b;</span>
 145:        : <span class="white">        }&#x200b;</span>
 146:        : <span class="white">&#x200b;</span>
 147:        : <span class="white">        private static IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; GroupVariablesByType(MethodDefinition method)&#x200b;</span>
 148:        : <span class="white">        {&#x200b;</span>
 149:        : <span class="white">            IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables = new Dictionary&lt;TypeReference, IList&lt;Variable&gt;&gt;();&#x200b;</span>
 150:        : <span class="white">            int offset = method.IsStatic ? 0 : 1;&#x200b;</span>
 151:        : <span class="white">            foreach (var parameter in method.Parameters)&#x200b;</span>
 152:        : <span class="white">            {&#x200b;</span>
 153:        : <span class="white">                var type = parameter.ParameterType;&#x200b;</span>
 154:        : <span class="white">                if (!variables.ContainsKey(type))&#x200b;</span>
 155:        : <span class="white">                {&#x200b;</span>
 156:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());&#x200b;</span>
 157:        : <span class="white">                }&#x200b;</span>
 158:        : <span class="white">                variables[type].Add(new Variable(VariableType.Parameter, parameter.Index + offset, parameter.Name));&#x200b;</span>
 159:        : <span class="white">            }&#x200b;</span>
 160:        : <span class="white">            foreach (var variable in method.Body.Variables)&#x200b;</span>
 161:        : <span class="white">            {&#x200b;</span>
 162:        : <span class="white">                var type = variable.VariableType;&#x200b;</span>
 163:        : <span class="white">                if (!variables.ContainsKey(type))&#x200b;</span>
 164:        : <span class="white">                {&#x200b;</span>
 165:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());&#x200b;</span>
 166:        : <span class="white">                }&#x200b;</span>
 167:        : <span class="white">                variables[type].Add(new Variable(VariableType.Local, variable.Index, variable.Name));&#x200b;</span>
 168:        : <span class="white">            }&#x200b;</span>
 169:        : <span class="white">            foreach (var field in method.DeclaringType.Fields)&#x200b;</span>
 170:        : <span class="white">            {&#x200b;</span>
 171:        : <span class="white">                if (field.Name == "&lt;&gt;1__state") continue;&#x200b;</span>
 172:        : <span class="white">                var type = field.FieldType;&#x200b;</span>
 173:        : <span class="white">                if (!variables.ContainsKey(type))&#x200b;</span>
 174:        : <span class="white">                {&#x200b;</span>
 175:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());&#x200b;</span>
 176:        : <span class="white">                }&#x200b;</span>
 177:        : <span class="white">                variables[type].Add(new Variable(VariableType.Field, -1, field.Name));&#x200b;</span>
 178:        : <span class="white">            }&#x200b;</span>
 179:        : <span class="white">            return variables;&#x200b;</span>
 180:        : <span class="white">        }&#x200b;</span>
 181:        : <span class="white">&#x200b;</span>
 182:        : <span class="white">        private static void PopulateOperandsInVariables(MethodDefinition method, IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables)&#x200b;</span>
 183:        : <span class="white">        {&#x200b;</span>
 184:        : <span class="white">            foreach (var instruction in method.Body.Instructions)&#x200b;</span>
 185:        : <span class="white">            {&#x200b;</span>
 186:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldarg)&#x200b;</span>
 187:        : <span class="white">                {&#x200b;</span>
 188:        : <span class="white">                    var parameterDefinition = (ParameterDefinition)instruction.Operand;&#x200b;</span>
 189:        : <span class="white">                    int sequence = parameterDefinition.Sequence;&#x200b;</span>
 190:        : <span class="white">                    if (!variables.ContainsKey(parameterDefinition.ParameterType)) continue;&#x200b;</span>
 191:        : <span class="white">                    var variable =&#x200b;</span>
 192:        : <span class="white">                        variables[parameterDefinition.ParameterType]&#x200b;</span>
 193:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Parameter &amp;&amp; v.Index == sequence);&#x200b;</span>
 194:        : <span class="white">                    if (variable != null)&#x200b;</span>
 195:        : <span class="white">                    {&#x200b;</span>
 196:        : <span class="white">                        variable.Operand = instruction.Operand;&#x200b;</span>
 197:        : <span class="white">                    }&#x200b;</span>
 198:        : <span class="white">                }&#x200b;</span>
 199:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldloc)&#x200b;</span>
 200:        : <span class="white">                {&#x200b;</span>
 201:        : <span class="white">                    var variableDefinition = (VariableDefinition)instruction.Operand;&#x200b;</span>
 202:        : <span class="white">                    int index = variableDefinition.Index;&#x200b;</span>
 203:        : <span class="white">                    if (!variables.ContainsKey(variableDefinition.VariableType)) continue;&#x200b;</span>
 204:        : <span class="white">                    var variable =&#x200b;</span>
 205:        : <span class="white">                        variables[variableDefinition.VariableType]&#x200b;</span>
 206:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == index);&#x200b;</span>
 207:        : <span class="white">                    if (variable != null)&#x200b;</span>
 208:        : <span class="white">                    {&#x200b;</span>
 209:        : <span class="white">                        variable.Operand = instruction.Operand;&#x200b;</span>
 210:        : <span class="white">                    }&#x200b;</span>
 211:        : <span class="white">                }&#x200b;</span>
 212:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldfld)&#x200b;</span>
 213:        : <span class="white">                {&#x200b;</span>
 214:        : <span class="white">                    var fieldDefinition = (FieldDefinition)instruction.Operand;&#x200b;</span>
 215:        : <span class="white">                    string name = fieldDefinition.Name;&#x200b;</span>
 216:        : <span class="white">                    if (!variables.ContainsKey(fieldDefinition.FieldType)) continue;&#x200b;</span>
 217:        : <span class="white">                    var variable =&#x200b;</span>
 218:        : <span class="white">                        variables[fieldDefinition.FieldType]&#x200b;</span>
 219:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == name);&#x200b;</span>
 220:        : <span class="white">                    if (variable != null)&#x200b;</span>
 221:        : <span class="white">                    {&#x200b;</span>
 222:        : <span class="white">                        variable.Operand = instruction.Operand;&#x200b;</span>
 223:        : <span class="white">                    }&#x200b;</span>
 224:        : <span class="white">                }&#x200b;</span>
 225:        : <span class="white">            }&#x200b;</span>
 226:        : <span class="white">        }&#x200b;</span>
 227:        : <span class="white">    }&#x200b;</span>
 228:        : <span class="white">}&#x200b;</span>
</pre><h1>VariableWriteTurtle.cs</h1><pre class="brush:csharp"><span class="title">Line: Mutants: Source code                                                                       </span>
   1:        : <span class="white">#region Copyright &amp; licence&#x200b;</span>
   2:        : <span class="white">&#x200b;</span>
   3:        : <span class="white">// This file is part of NinjaTurtles.&#x200b;</span>
   4:        : <span class="white">// &#x200b;</span>
   5:        : <span class="white">// NinjaTurtles is free software: you can redistribute it and/or modify&#x200b;</span>
   6:        : <span class="white">// it under the terms of the GNU Lesser General Public License as&#x200b;</span>
   7:        : <span class="white">// published by the Free Software Foundation, either version 3 of the&#x200b;</span>
   8:        : <span class="white">// License, or (at your option) any later version.&#x200b;</span>
   9:        : <span class="white">// &#x200b;</span>
  10:        : <span class="white">// NinjaTurtles is distributed in the hope that it will be useful,&#x200b;</span>
  11:        : <span class="white">// but WITHOUT ANY WARRANTY; without even the implied warranty of&#x200b;</span>
  12:        : <span class="white">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&#x200b;</span>
  13:        : <span class="white">// GNU Lesser General Public License for more details.&#x200b;</span>
  14:        : <span class="white">// &#x200b;</span>
  15:        : <span class="white">// You should have received a copy of the GNU Lesser General Public&#x200b;</span>
  16:        : <span class="white">// License along with NinjaTurtles.  If not, see &lt;http://www.gnu.org/licenses/&gt;.&#x200b;</span>
  17:        : <span class="white">// &#x200b;</span>
  18:        : <span class="white">// Copyright (C) 2012 David Musgrove and others.&#x200b;</span>
  19:        : <span class="white">&#x200b;</span>
  20:        : <span class="white">#endregion&#x200b;</span>
  21:        : <span class="white">&#x200b;</span>
  22:        : <span class="white">using System;&#x200b;</span>
  23:        : <span class="white">using System.Collections.Generic;&#x200b;</span>
  24:        : <span class="white">using System.Linq;&#x200b;</span>
  25:        : <span class="white">&#x200b;</span>
  26:        : <span class="white">using Mono.Cecil;&#x200b;</span>
  27:        : <span class="white">using Mono.Cecil.Cil;&#x200b;</span>
  28:        : <span class="white">&#x200b;</span>
  29:        : <span class="white">namespace NinjaTurtles.Turtles&#x200b;</span>
  30:        : <span class="white">{&#x200b;</span>
  31:        : <span class="white">    /// &lt;summary&gt;&#x200b;</span>
  32:        : <span class="white">    /// An implementation of &lt;see cref="IMethodTurtle" /&gt; that identifies local&#x200b;</span>
  33:        : <span class="white">    /// variables of the same type, and permutes any assignments to them. For&#x200b;</span>
  34:        : <span class="white">    /// example, if two &lt;see cref="Int32" /&gt; variables &lt;c&gt;a&lt;/c&gt; and &lt;c&gt;b&lt;/c&gt;&#x200b;</span>
  35:        : <span class="white">    /// exist, then an assignment to &lt;c&gt;a&lt;/c&gt; will be replaced by one to&#x200b;</span>
  36:        : <span class="white">    /// &lt;c&gt;b&lt;/c&gt;, and vice versa.&#x200b;</span>
  37:        : <span class="white">    /// &lt;/summary&gt;&#x200b;</span>
  38:        : <span class="white">    public class VariableWriteTurtle : MethodTurtleBase&#x200b;</span>
  39:        : <span class="white">    {&#x200b;</span>
  40:        : <span class="white">        /// &lt;summary&gt;&#x200b;</span>
  41:        : <span class="white">        /// Performs the actual code mutations, returning each with&#x200b;</span>
  42:        : <span class="white">        /// &lt;c&gt;yield&lt;/c&gt; for the calling code to use.&#x200b;</span>
  43:        : <span class="white">        /// &lt;/summary&gt;&#x200b;</span>
  44:        : <span class="white">        /// &lt;remarks&gt;&#x200b;</span>
  45:        : <span class="white">        /// Implementing classes should yield the result obtained by calling&#x200b;</span>
  46:        : <span class="white">        /// the &lt;see mref="DoYield" /&gt; method.&#x200b;</span>
  47:        : <span class="white">        /// &lt;/remarks&gt;&#x200b;</span>
  48:        : <span class="white">        /// &lt;param name="method"&gt;&#x200b;</span>
  49:        : <span class="white">        /// A &lt;see cref="MethodDefinition" /&gt; for the method on which mutation&#x200b;</span>
  50:        : <span class="white">        /// testing is to be carried out.&#x200b;</span>
  51:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  52:        : <span class="white">        /// &lt;param name="module"&gt;&#x200b;</span>
  53:        : <span class="white">        /// A &lt;see cref="Module" /&gt; representing the main module of the&#x200b;</span>
  54:        : <span class="white">        /// containing assembly.&#x200b;</span>
  55:        : <span class="white">        /// &lt;/param&gt;&#x200b;</span>
  56:        : <span class="white">        /// &lt;returns&gt;&#x200b;</span>
  57:        : <span class="white">        /// An &lt;see cref="IEnumerable{T}" /&gt; of&#x200b;</span>
  58:        : <span class="white">        /// &lt;see cref="MutantMetaData" /&gt; structures.&#x200b;</span>
  59:        : <span class="white">        /// &lt;/returns&gt;&#x200b;</span>
  60:        : <span class="white">        protected override IEnumerable&lt;MutantMetaData&gt; DoMutate(MethodDefinition method, Module module)&#x200b;</span>
  61:        : <span class="white">        {&#x200b;</span>
  62:     1/1: <span class="green">            var variablesByType = GroupVariablesByType(method);&#x200b;</span>
  63:     1/1: <span class="green">            PopulateOperandsInVariables(method, variablesByType);&#x200b;</span>
  64:        : <span class="white">&#x200b;</span>
  65:   13/13: <span class="green">            foreach (var keyValuePair in variablesByType.Where(kv =&gt; kv.Value.Count &gt; 1))&#x200b;</span>
  66:        : <span class="white">            {&#x200b;</span>
  67:     1/1: <span class="green">                var variables = keyValuePair.Value.ToList();&#x200b;</span>
  68:   22/22: <span class="green">                for (int index = 0; index &lt; method.Body.Instructions.Count; index++)&#x200b;</span>
  69:        : <span class="white">                {&#x200b;</span>
  70:     4/4: <span class="green">                    var instruction = method.Body.Instructions[index];&#x200b;</span>
  71:     8/8: <span class="green">                    if (instruction.IsPartOfCompilerGeneratedDispose()) continue;&#x200b;</span>
  72:        : <span class="white">&#x200b;</span>
  73:     4/4: <span class="green">                    int oldIndex = -1;&#x200b;</span>
  74:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Stloc)&#x200b;</span>
  75:        : <span class="white">                    {&#x200b;</span>
  76:     1/1: <span class="green">                        int variableIndex = ((VariableDefinition)instruction.Operand).Index;&#x200b;</span>
  77:     4/4: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == variableIndex);&#x200b;</span>
  78:        : <span class="white">                    }&#x200b;</span>
  79:     7/7: <span class="green">                    if (instruction.OpCode == OpCodes.Stfld)&#x200b;</span>
  80:        : <span class="white">                    {&#x200b;</span>
  81:     1/1: <span class="green">                        string fieldName = ((FieldDefinition)instruction.Operand).Name;&#x200b;</span>
  82:     4/4: <span class="green">                        oldIndex = variables.FindIndex(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == fieldName);&#x200b;</span>
  83:        : <span class="white">                    }&#x200b;</span>
  84:        : <span class="white">&#x200b;</span>
  85:   12/12: <span class="green">                    if (oldIndex &lt; 0) continue;&#x200b;</span>
  86:        : <span class="white">&#x200b;</span>
  87:        : <span class="white">                    // Skip if could be initialising to zero, as in reality&#x200b;</span>
  88:        : <span class="white">                    // this has already been done by the CLR.&#x200b;</span>
  89:   10/10: <span class="green">                    if (instruction.Previous.OpCode == OpCodes.Ldc_I4&#x200b;</span>
  90:   10/10: <span class="green">                        &amp;&amp; (int)instruction.Previous.Operand == 0)&#x200b;</span>
  91:        : <span class="white">                    {&#x200b;</span>
  92:     1/1: <span class="green">                        continue;&#x200b;</span>
  93:        : <span class="white">                    }&#x200b;</span>
  94:        : <span class="white">&#x200b;</span>
  95:     1/1: <span class="green">                    OpCode originalOpCode = instruction.OpCode;&#x200b;</span>
  96:     1/1: <span class="green">                    object originalOperand = instruction.Operand;&#x200b;</span>
  97:     5/5: <span class="green">                    var originalVariable = variables[oldIndex];&#x200b;</span>
  98:        : <span class="white">&#x200b;</span>
  99:   22/22: <span class="green">                    for (int newIndex = 0; newIndex &lt; variables.Count; newIndex++)&#x200b;</span>
 100:        : <span class="white">                    {&#x200b;</span>
 101:   14/14: <span class="green">                        if (newIndex == oldIndex) continue;&#x200b;</span>
 102:     5/5: <span class="green">                        var variable = variables[newIndex];&#x200b;</span>
 103:     9/9: <span class="green">                        if (variable.Operand == null) continue;&#x200b;</span>
 104:        : <span class="white">&#x200b;</span>
 105:     2/2: <span class="green">                        instruction.OpCode = variable.GetWriteOpCode();&#x200b;</span>
 106:     2/2: <span class="green">                        instruction.Operand = variable.Operand;&#x200b;</span>
 107:        : <span class="white">&#x200b;</span>
 108:     6/6: <span class="green">                        var description =&#x200b;</span>
 109:     6/6: <span class="green">                            string.Format(&#x200b;</span>
 110:     6/6: <span class="green">                                "{0:x4}: write substitution {1}.{2} =&gt; {1}.{3}",&#x200b;</span>
 111:     6/6: <span class="green">                                GetOriginalOffset(index),&#x200b;</span>
 112:     6/6: <span class="green">                                keyValuePair.Key.Name,&#x200b;</span>
 113:     6/6: <span class="green">                                originalVariable.Name,&#x200b;</span>
 114:     6/6: <span class="green">                                variable.Name);&#x200b;</span>
 115:        : <span class="white">&#x200b;</span>
 116:     6/6: <span class="green">                        yield return DoYield(method, module, description, index);&#x200b;</span>
 117:        : <span class="white">&#x200b;</span>
 118:        : <span class="white">                    }&#x200b;</span>
 119:     1/1: <span class="green">                    instruction.OpCode = originalOpCode;&#x200b;</span>
 120:     1/1: <span class="green">                    instruction.Operand = originalOperand;&#x200b;</span>
 121:        : <span class="white">                }&#x200b;</span>
 122:        : <span class="white">            }&#x200b;</span>
 123:        : <span class="white">        }&#x200b;</span>
 124:        : <span class="white">&#x200b;</span>
 125:        : <span class="white">        private static IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; GroupVariablesByType(MethodDefinition method)&#x200b;</span>
 126:        : <span class="white">        {&#x200b;</span>
 127:        : <span class="white">            IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables = new Dictionary&lt;TypeReference, IList&lt;Variable&gt;&gt;();&#x200b;</span>
 128:        : <span class="white">            foreach (var variable in method.Body.Variables)&#x200b;</span>
 129:        : <span class="white">            {&#x200b;</span>
 130:        : <span class="white">                var type = variable.VariableType;&#x200b;</span>
 131:        : <span class="white">                if (!variables.ContainsKey(type))&#x200b;</span>
 132:        : <span class="white">                {&#x200b;</span>
 133:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());&#x200b;</span>
 134:        : <span class="white">                }&#x200b;</span>
 135:        : <span class="white">                variables[type].Add(new Variable(VariableType.Local, variable.Index, variable.Name));&#x200b;</span>
 136:        : <span class="white">            }&#x200b;</span>
 137:        : <span class="white">            foreach (var field in method.DeclaringType.Fields)&#x200b;</span>
 138:        : <span class="white">            {&#x200b;</span>
 139:        : <span class="white">                if (field.Name == "&lt;&gt;1__state") continue;&#x200b;</span>
 140:        : <span class="white">                var type = field.FieldType;&#x200b;</span>
 141:        : <span class="white">                if (!variables.ContainsKey(type))&#x200b;</span>
 142:        : <span class="white">                {&#x200b;</span>
 143:        : <span class="white">                    variables.Add(type, new List&lt;Variable&gt;());&#x200b;</span>
 144:        : <span class="white">                }&#x200b;</span>
 145:        : <span class="white">                variables[type].Add(new Variable(VariableType.Field, -1, field.Name));&#x200b;</span>
 146:        : <span class="white">            }&#x200b;</span>
 147:        : <span class="white">            return variables;&#x200b;</span>
 148:        : <span class="white">        }&#x200b;</span>
 149:        : <span class="white">&#x200b;</span>
 150:        : <span class="white">        private static void PopulateOperandsInVariables(MethodDefinition method, IDictionary&lt;TypeReference, IList&lt;Variable&gt;&gt; variables)&#x200b;</span>
 151:        : <span class="white">        {&#x200b;</span>
 152:        : <span class="white">            foreach (var instruction in method.Body.Instructions)&#x200b;</span>
 153:        : <span class="white">            {&#x200b;</span>
 154:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldloc)&#x200b;</span>
 155:        : <span class="white">                {&#x200b;</span>
 156:        : <span class="white">                    var variableDefinition = (VariableDefinition)instruction.Operand;&#x200b;</span>
 157:        : <span class="white">                    int index = variableDefinition.Index;&#x200b;</span>
 158:        : <span class="white">                    if (!variables.ContainsKey(variableDefinition.VariableType)) continue;&#x200b;</span>
 159:        : <span class="white">                    var variable =&#x200b;</span>
 160:        : <span class="white">                        variables[variableDefinition.VariableType]&#x200b;</span>
 161:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Local &amp;&amp; v.Index == index);&#x200b;</span>
 162:        : <span class="white">                    if (variable != null)&#x200b;</span>
 163:        : <span class="white">                    {&#x200b;</span>
 164:        : <span class="white">                        variable.Operand = instruction.Operand;&#x200b;</span>
 165:        : <span class="white">                    }&#x200b;</span>
 166:        : <span class="white">                }&#x200b;</span>
 167:        : <span class="white">                if (instruction.OpCode == OpCodes.Ldfld)&#x200b;</span>
 168:        : <span class="white">                {&#x200b;</span>
 169:        : <span class="white">                    var fieldDefinition = (FieldDefinition)instruction.Operand;&#x200b;</span>
 170:        : <span class="white">                    string name = fieldDefinition.Name;&#x200b;</span>
 171:        : <span class="white">                    if (!variables.ContainsKey(fieldDefinition.FieldType)) continue;&#x200b;</span>
 172:        : <span class="white">                    var variable =&#x200b;</span>
 173:        : <span class="white">                        variables[fieldDefinition.FieldType]&#x200b;</span>
 174:        : <span class="white">                            .SingleOrDefault(v =&gt; v.Type == VariableType.Field &amp;&amp; v.Name == name);&#x200b;</span>
 175:        : <span class="white">                    if (variable != null)&#x200b;</span>
 176:        : <span class="white">                    {&#x200b;</span>
 177:        : <span class="white">                        variable.Operand = instruction.Operand;&#x200b;</span>
 178:        : <span class="white">                    }&#x200b;</span>
 179:        : <span class="white">                }&#x200b;</span>
 180:        : <span class="white">            }&#x200b;</span>
 181:        : <span class="white">        }&#x200b;</span>
 182:        : <span class="white">    }&#x200b;</span>
 183:        : <span class="white">}&#x200b;</span>
</pre></body></html>